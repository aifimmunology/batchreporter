---
title: "scRNA Seq Batch Summary: `r {params$batch}`"
author: 
 -
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    self_contained: true
  tables: yes
params:
  batch: NULL
  in_dir: NULL
  in_key: NULL
  out_dir: NULL
---

<!-- Set Up ---------------------------------------------------------------- -->
```{r setup, echo = FALSE, include = TRUE}
# Load Libraries  
start_time <- Sys.time()

test_format_hook <- TRUE

knitr::opts_chunk$set(echo = FALSE, cache = FALSE, autodep = TRUE)

quiet_library <- function(...) {
  suppressPackageStartupMessages(library(...))
}

quiet_library(Matrix)        # dependency pf H5weaver
quiet_library(rhdf5)         # dependency of H5weaver
quiet_library(H5weaver)      # aifi package
quiet_library(HTOparser)     # aifi package
quiet_library(ggplot2)       
quiet_library(dplyr)         # data wranglingN
quiet_library(cowplot)       # arranging multiple plots
quiet_library(gt)            # formatted table output
quiet_library(plotly)        # interactive plotsO
quiet_library(immutils)      # general functions, aifi package
quiet_library(tidyr)         # data wrangling
quiet_library(Seurat)        # batch umap creation
# quiet_library(inflection)    # batch umap creation--pca dimensionality determination
quiet_library(future)        # multi-threading for batch umap creation
quiet_library(future.apply)  # multi-threading for batch umap creation

stm(paste(c("\t",paste(names(Sys.info()),Sys.info(),sep = ": ")), collapse = "\n\t"))
```  

```{css style_definitions}
# Allow display of large images without shrinking to page width
<style>
  .superbigimage{
      overflow-x:scroll;
  }

  .superbigimage img{
     max-width: none;
  }

</style>
    
```  

```{r variable_definitions}
control_sample_pattern <- "IMM\\d{2}[_-]\\d{3}"  
fct_mito_umi_threshold <- 0.10
is_test <- FALSE
cell_type_palette <- data.frame(
  seurat3_pbmc_type = c("B cell progenitor", "CD14+ Monocytes", "CD16+ Monocytes",
                       "CD4 Memory", "CD4 Naive","CD8 effector", "CD8 Naive", 
                       "Dendritic cell", "Double negative T cell", "NK cell",
                       "pDC", "Platelets", "pre-B cell"),
  cell_color = c("#FF0000","#FF8C00","#FFEE00","#44FF00", "#00E1FF","#0000FF",
                 "#E546FA","#F598E5","#008A12", "#803CCF", "#967729", "#B1C4F0",
                 "#DCF0B1"), 
  stringsAsFactors = FALSE
)

```

<!-- Argument parsing --------------------------------------------------------->
```{r Parse arguments}
if(is.null(params$in_dir)) {
  # in_dir <- system.file("testdata", package = "scrna-batch-summary")
  # in_dir <- "~/Packages/scrna-batch-report/inst/extdata"
  in_dir <- "/home/jupyter/scrna-batch-report/inst/extdata"

  batch <- "T001"
  #in_key <- "~/Packages/scrna-batch-report/inst/extdata/example_sample_key.csv"
  in_key <- "/home/jupyter/scrna-batch-report/inst/extdata/example_sample_key.csv"

} else {
  in_dir <- params$in_dir
  batch <-  params$batch
  in_key <- params$in_key
  out_dir <- params$out_dir
}

stm(paste0("IN Batch        : ", batch))
stm(paste0("IN Directory     : ", in_dir))
stm(paste0("IN Sample Key   : ", in_key))
# stm(paste0("OUT Cell Label Table: ", out_tbl))
```

```{r input_todelete}
# # Delete this section after defining param structure
# # in_dir_labeled <- "~/rnaseq_qc_report/test_data/B002/rna"
# # in_dir_labeled <- "~/Projects/Exploration/B002/rna/"
# in_dir <- "~/Packages/scrna-batch-report/inst/extdata/"
# # in_dir_hto <- "~/rnaseq_qc_report/test_data/B002/rna/hto"
# # in_dir_hto <- "~/Projects/Exploration/B002/rna/hto"
# # in_dir_mult <- "~/Projects/Exploration/B002/rna/hto"
# # in_dir_ctrl <- "~/Projects/Exploration/controls/"
# out_dir <- ""

``` 
  
```{r functions}
# NEEDS UPDATE CLOSER TO FINALIZATION BASED ON LOCATIONS OF FUNCTIONS AND POTENTIALLY UPDATED PACKAGES
# values <- sample(1:100,10)

#' Get median and range
#' 
#' Gets median and range of numeric vector, rounding to specified digits with option
#' to include the number of missing values
#'
get_median_range <- function(values, digits_round = 1, add_missing = TRUE, verbose = TRUE){
  assertthat::assert_that(mode(values) == "numeric" | all(is.na(values))) # can be any type of numeric, allow calculation if all missing
  assertthat::assert_that(length(values) > 0)
  
  value_fmt <- paste0("%.",digits_round,"f")
  
  i_missing <- which(is.na(values))
  n_missing <- length(i_missing)
  has_missing <- n_missing > 0
  
  if(has_missing){
    values <- values[-i_missing]
  }
  
  values_round <- round(values, digits_round)
  
  med_string <- sprintf(value_fmt, median(values_round))
  
  if(length(values_round) > 0){
    range <- sprintf(value_fmt, range(values_round))
  } else {
    range <- c(NA,NA)
  }
  range_string <- paste(range, collapse = "-")
  median_range <- sprintf("%s (%s)", med_string, range_string)
  
  if(add_missing & has_missing){
    median_range <- sprintf("%s [%s]", median_range, n_missing)
  }
  
  if(verbose){
    cat(sprintf("Median and range calculated. Removed %s missing values", n_missing), sep = "\n")
  }
  
  return(median_range)
}

# tests
# get_median_range(1:10, digits_round = 2, add_missing = TRUE, verbose = TRUE)
# get_median_range(1:10, digits_round = 1, add_missing = FALSE, verbose = TRUE)
# get_median_range(1:10, digits_round = 1, add_missing = TRUE, verbose = TRUE)
# get_median_range(1:10, digits_round = 1, add_missing = TRUE, verbose = TRUE)
# get_median_range(c(1:10,NA), digits_round = 1, add_missing = TRUE, verbose = TRUE)
# get_median_range(c(NA,NA,1), digits_round = 1, add_missing = TRUE, verbose = TRUE)
# get_median_range(c(NA,NA), digits_round = 1, add_missing = TRUE, verbose = TRUE)
# get_median_range(c(NaN,NaN), digits_round = 2, add_missing = TRUE, verbose = TRUE)
# set.seed(1)
# get_median_range(rnorm(20), digits_round = 3, add_missing = TRUE, verbose = TRUE)
# get_median_range(rnorm(20), digits_round = 3, add_missing = TRUE, verbose = FALSE)



# determine_passing_spec <- function(values, lower_threshold = NULL, upper_threshold = NULL, digits_round = 0, pass_at_threshold = TRUE){
#   assertthat::assert_that(mode(values) == "numeric")
#   assertthat::assert_that(length(values) >= 1)
#   
#   values_round <- round(values, digits_round)
#   
#   if(!is.null(lower_threshold)){
#     i_low <- which(values <= )
#   }
#   
#   if(pass_at_threshold){
#     i_low <- which(values_round < lower_threshold)
#   }
# 
# }

read_h5_well_meta <- function (h5_file, target = "well") {
  assertthat::assert_that(is.character(h5_file))
  assertthat::assert_that(length(h5_file) == 1)
  target <- ifelse(grepl("^/", target), target, paste0("/", 
                                                       target))
  h5_contents <- H5weaver::h5ls(h5_file)
  target_contents <- h5_contents[grepl(paste0("^", target,"$"), 
                                       h5_contents$group), ]
  h5_meta_targets <- target_contents$full_name
  
  if (length(h5_meta_targets) > 0) {
    meta_list <- lapply(h5_meta_targets, function(h5_meta_target) {
      rhdf5::h5read(h5_file, h5_meta_target)
    })
    rhdf5::h5closeAll()
    names(meta_list) <- sub(".+/", "", h5_meta_targets)
    meta_list <- strip_1d_array_recursive(meta_list)
    meta_list <- convert_char_na_recursive(meta_list)
    df <- as.data.frame(meta_list, stringsAsFactors = FALSE)
    if("well_id" %in% names(df)){
      df <- df[, c("well_id", setdiff(names(df),"well_id"))]
    }
    df
  }
  else {
    stop("No well metadata found in h5_file.")
  }
}

simple_html_table <- function(labels, values, col.names = NULL, col_widths_px = c(300, 800), fontsize = 2){
  assertthat::assert_that(length(col_widths_px) %in% c(1,2))
  assertthat::assert_that(length(labels) == length(values))
  assertthat::assert_that(all(col_widths_px > 100) & all(col_widths_px < 1024))
  assertthat::assert_that(ifelse(is.null(col.names),TRUE, length(col.names) == 2))
  assertthat::assert_that(is.null(col.names) | class(col.names) == "character")
  
  if(length(col_widths_px) == 1){
    col_widths_px <- c(col_widths_px, col_widths_px)
  }

  create_row <- function(value1, value2 , col_widths_px = c(50, 50)){
    sprintf('<tr>
                <td style="width:%spx">
                  %s
                </td>
                <td style="width:%spx">
                  %s
                </td>
            </tr>',
            col_widths_px[1], value1, col_widths_px[2], value2)
  }

  add_table_wrap <- function(all_row_string, fontsize = 2, col_widths_px= c(50,50)){
    sprintf('<font size="%s">
            <style>
              table {
                border: 1px solid black;
                border-collapse: collapse;
              }
              td {
                padding: 5px;
                border: 1px solid black;
                border-collapse: collapse;
              }
            </style>
            <table>
              <colgroup>
                <col span="1" style="width: %spx;">
                <col span="1" style="width: %spx;">
              </colgroup>
              <tbody>
                %s
              </tbody>
            </table>
            </font>', fontsize, col_widths_px[1], col_widths_px[2], all_row_string)
  }
  
  row_strings <- character()
  for (i in seq_along(labels)){
    row_strings[i] <- create_row(labels[i], values[i], col_widths_px = col_widths_px)
  }
  row_string_all <- paste(row_strings, collapse = "")
  
  out_table <- add_table_wrap(row_string_all,fontsize = fontsize, col_widths_px = col_widths_px )
  
  htmltools::HTML(out_table)
}

gt_fmt_comments <- function(x) {
  x %>% 
    gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.3)
      ),
    locations = cells_body(
      columns = vars(Comments),
      rows = grepl("Warning",Comments))
  ) %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.5)
      ),
    locations = cells_body(
      columns = vars(Comments),
      rows = grepl("Fail",Comments))
  ) 
}

# 
# get_gene_scores <- function(count_matrix, gene){
#   gene_counts <- count_matrix[gene, ]
#   return(gene_counts)
# }

read_hto_well_json <- function(fp){
  assertthat::assert_that(length(fp) == 1)
  
  # keep_cols <- c("well_id", "hto_barcode", "hash_tag", "cutoff", "n_pos",
  #                "n_neg", "n_below_threshold", "frac_pos", "frac_neg", 
  #                "frac_below_threshold", "n_singlets","n_cells", "frac_cells")
  
  json_list <- jsonlite::read_json(fp)
  
  well_id <- json_list$well_id
  sample_stats_list <- json_list$pbmc_sample_hto_stats
  sample_stats_df_list <- lapply(seq_along(sample_stats_list), function(i){
    df <- data.frame(pbmc_sample_id = names(sample_stats_list)[i])
    stats_list <- lapply(sample_stats_list[[i]], function(x){
      ifelse(is.null(x),NA, x)
    })
    df <- cbind(df, as.data.frame(stats_list))
    df
  })
  
  sample_stats_df <- do.call(rbind, sample_stats_df_list)
  results <- data.frame(well_id = rep(well_id, nrow (sample_stats_df)),sample_stats_df)
}


qc_stacked_barplot_mod <- function (meta, category_x = "batch_id", name_x = "Batch ID", 
  category_y = "well_id", category_name = "Well ID", colorset_y = "varibow", 
  name_y = "N Cells", as_fraction = FALSE, facet_formula = NULL, facet_rows = NULL,...) {
  assertthat::assert_that(sum(class(meta) %in% c("data.frame", 
    "data.table")) > 0)
  assertthat::assert_that(class(category_x) == "character")
  assertthat::assert_that(length(category_x) == 1)
  assertthat::assert_that(category_x %in% names(meta))
  assertthat::assert_that(class(name_x) == "character")
  assertthat::assert_that(length(name_x) == 1)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(class(name_y) == "character")
  assertthat::assert_that(length(name_y) == 1)
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow", "varibow"))
  assertthat::assert_that(class(as_fraction) == "logical")
  assertthat::assert_that(length(as_fraction) == 1)
  assertthat::assert_that(is.null(facet_formula) || is_formula(facet_formula))
  meta <- as.data.table(meta)
  
  if(!is.null(facet_formula)){
    formula_cols <- as.character(as.list(facet_formula))
    f_cols <- setdiff(formula_cols, "`~`")
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
    category_y, f_cols))]
  } else {
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
    category_y))]
  }
  plot_xpos <- data.frame(unique(count_table[[category_x]]))
  names(plot_xpos) <- category_x
  plot_xpos <- plot_xpos[order(plot_xpos[[category_x]]), , 
    drop = FALSE]
  plot_xpos$xpos <- 1:nrow(plot_xpos)
  count_table <- count_table[plot_xpos, on = category_x]
  plot_fills <- data.frame(unique(count_table[[category_y]]))
  names(plot_fills) <- category_y
  if (colorset_y == "rainbow") {
    set.seed(3030)
    plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  else if (colorset_y == "varibow") {
    set.seed(3030)
    plot_fills$fill <- sample(immutils::varibow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  plot_fills <- plot_fills[order(plot_fills[[category_y]]), 
    ]
  count_table <- count_table[plot_fills, on = category_y]
  count_table <- count_table[order(get(category_y), decreasing = TRUE)]
  if (as_fraction) {
    count_table <- count_table[, `:=`(ymax, cumsum(n_cells)/sum(n_cells)), 
      by = list(get(category_x))]
    count_table <- count_table[, `:=`(ymin, shift(ymax, 
      fill = 0, type = "lag")), by = list(get(category_x))]
  }
  p <- ggplot2::ggplot() + ggplot2::geom_rect(data = count_table, 
    ggplot2::aes(xmin = xpos - 0.4, xmax = xpos + 0.4, ymin = ymin, 
      ymax = ymax, fill = fill)) + ggplot2::scale_fill_identity(category_name, 
    breaks = plot_fills$fill, labels = plot_fills[[category_y]], 
    guide = "legend") + ggplot2::scale_x_continuous(name_x, 
    breaks = plot_xpos$xpos, labels = plot_xpos[[category_x]]) + 
    ggplot2::scale_y_continuous(name_y) + ggplot2::theme_bw() + 
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, 
      hjust = 1, vjust = 0.3))
  if(!is.null(facet_formula)){
    p <- p +
      facet_wrap(facet_formula, nrow = facet_rows, ...)
  }
  p
}

qc_aligned_barplot_mod <- function (meta, category_x = "batch_id", 
                                    name_x = "Batch ID", 
                                    category_y = "well_id", 
                                    category_name = "Well ID", 
                                    colorset_y = "varibow", 
                                    name_y = "N Cells", padding = 0.2,
                                     facet_formula = NULL, facet_rows = NULL,...) {
  assertthat::assert_that(sum(class(meta) %in% c("data.frame", 
    "data.table")) > 0)
  assertthat::assert_that(class(category_x) == "character")
  assertthat::assert_that(length(category_x) == 1)
  assertthat::assert_that(category_x %in% names(meta))
  assertthat::assert_that(class(name_x) == "character")
  assertthat::assert_that(length(name_x) == 1)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(class(name_y) == "character")
  assertthat::assert_that(length(name_y) == 1)
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow", "varibow"))
  assertthat::assert_that(class(padding) == "numeric")
  assertthat::assert_that(length(padding) == 1)
  assertthat::assert_that(padding < 1)
  tidy_x <- rlang::parse_expr(category_x)
  tidy_y <- rlang::parse_expr(category_y)
  meta <- as.data.table(meta)
  if(!is.null(facet_formula)){
    formula_cols <- as.character(as.list(facet_formula))
    f_cols <- setdiff(formula_cols, "`~`")
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
                                                              category_y, f_cols))]
  } else {
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
                                                              category_y))]
  }
  plot_xpos <- data.frame(unique(count_table[[category_x]]))
  names(plot_xpos) <- category_x
  plot_xpos <- plot_xpos[order(plot_xpos[[category_x]]), , 
    drop = FALSE]
  plot_xpos$xpos <- 1:nrow(plot_xpos)
  count_table <- count_table[plot_xpos, on = category_x]

  plot_fills <- data.frame(unique(count_table[[category_y]]))
  names(plot_fills) <- category_y
  if (colorset_y == "rainbow") {
    set.seed(3030)
    plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  else if (colorset_y == "varibow") {
    set.seed(3030)
    plot_fills$fill <- sample(immutils::varibow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  plot_fills <- plot_fills[order(plot_fills[[category_y]]), 
    ]
  count_table <- count_table[plot_fills, on = category_y]
  
  group_maxes <- count_table[, .(group_max = max(n_cells)), 
    by = list(get(category_y))]
  names(group_maxes)[1] <- category_y
  group_maxes <- group_maxes[order(get(category_y), decreasing = TRUE)]
  group_maxes <- group_maxes[, `:=`(cum_max, cumsum(group_max))]
  group_maxes <- group_maxes[, `:=`(group_center, cum_max - 
    group_max/2)]
  group_maxes <- group_maxes[, `:=`(padded_center, group_center + 
    (max(cum_max) * (padding/nrow(group_maxes))) * (1:nrow(group_maxes) - 
      1))]
  group_maxes <- group_maxes[, `:=`(padded_base, padded_center - 
    group_max/2)]
  group_maxes <- group_maxes[, `:=`(padded_top, padded_center + 
    group_max/2)]
  count_table <- count_table[group_maxes, on = category_y]
  count_table <- count_table[order(get(category_y), decreasing = TRUE)]
  count_table <- count_table[, `:=`(ymax, cumsum(n_cells)), 
    by = list(get(category_x))]
  count_table <- count_table[, `:=`(ymin, shift(ymax, fill = 0, 
    type = "lag")), by = list(get(category_x))]
  p <- ggplot2::ggplot() + 
    ggplot2::geom_rect(data = count_table, ggplot2::aes(xmin = xpos - 0.4, 
                                                        xmax = xpos + 0.4, 
                                                        ymin = padded_base, 
                                                        ymax = padded_base + n_cells, 
                                                        fill = fill)) + 
    ggplot2::geom_hline(data = count_table, ggplot2::aes(yintercept = padded_base)) + 
    ggplot2::geom_hline(data = count_table, ggplot2::aes(yintercept = padded_top), linetype = "dashed") + 
    ggplot2::scale_fill_identity(category_name, breaks = plot_fills$fill, 
                                 labels = plot_fills[[category_y]], guide = "legend") + 
    ggplot2::scale_x_continuous(name_x, breaks = plot_xpos$xpos, 
      labels = plot_xpos[[category_x]]) + 
    ggplot2::scale_y_continuous(name_y, breaks = c(group_maxes$padded_base, group_maxes$padded_top), 
                                labels = c(rep("", nrow(group_maxes)), group_maxes$group_max), 
                                expand = ggplot2::expansion(c(0, 0.02))) + ggplot2::theme_bw() + 
    ggplot2::theme(panel.grid.minor.y = ggplot2::element_blank(), 
                   axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, vjust = 0.3))
  
   if(!is.null(facet_formula)){
    p <- p +
      facet_wrap(facet_formula, nrow = facet_rows, ...)
  }
  p
}


#' Add Axis Spacing for Faceted Plotly
#' 
#' 
#' 
#' @param plotly_obj An object generated by ggplotly
#' @param axis String value of "x" or "y". Which axis title to add spacing to.
#' If need to add spacing to both, make separate calls to `add_axis_title_spacing_plotly()`
#' @param n_lines Numeric value. Number of lines worth of spacing to add.
#' @return A the original plotly object with updated axis name
#' @examples
#' library(ggplot2)
#' library(plotly)
#' set.seed(1)
#' x <- sapply(1:10,function(x){paste(LETTERS[sample(1:26,10,replace = T)],collapse="")})
#' y <- sapply(1:20,function(x){paste(LETTERS[sample(1:26,10,replace = T)],collapse="")})
#' z <- rep(c("A","B"), times = 10)
#' df <- data.frame(x, y, z)
#' g <- ggplot(df, aes(x, y))+
#'   geom_point()+
#'   facet_wrap(~z, nrow =1) +
#'   xlab("X TITLE") +
#'   ylab("Y TITLE") +
#'   theme(axis.text.x = element_text(angle = 90))
#' g
#' gp <- ggplotly(g)
#' gp
#' gp %>% 
#'   add_axis_title_spacing_plotly("x", 3) %>% 
#'   add_axis_title_spacing_plotly("y", 3) 
#'

add_axis_title_spacing_plotly <- function(plotly_obj, axis, n_lines){
  assertthat::assert_that(is.character(axis))
  axis <- tolower(axis)
  assertthat::assert_that(axis %in% c("x","y"))
  assertthat::assert_that(is.numeric(n_lines))

  axis_string <- paste0(axis,"axis")
  
  annotation_index <- (axis=="y") + 1
  orig_title <- plotly_obj$x$layout$annotations[[annotation_index]]$text
  if(is.null(orig_title)){
    stop(sprintf("No title detected in plotly object for axis %s",x))
  }

  spacing_string <- paste("",rep("\n",n_lines), collapse = "")
  if(axis == "x"){
    newtitle <- paste0(spacing_string, orig_title)
  } else if (axis == "y"){
    newtitle <- paste0(orig_title, spacing_string)
  }

  plotly_obj$x$layout$annotations[[annotation_index]]$text <- newtitle

  return(plotly_obj)
}  

```


<!-- Parse Input ----------------------------------------------------------- -->
```{r find_files}
# Get list of all target files
all_labeled_h5 <- list.files(path = file.path(in_dir,"labeled_h5"), pattern = "_labeled.h5$", full.names = TRUE, recursive = TRUE)
all_hto_json <- list.files(path = file.path(in_dir,"hash"), pattern = "hto_processing_metrics.json$", full.names = TRUE, recursive = TRUE)
all_multiplet_h5 <- list.files(path = file.path(in_dir,"multiplet_h5"), pattern = "multiplet.h5$", full.names = TRUE, recursive = TRUE)
all_control_h5 <- list.files(path = file.path(in_dir,"control"), pattern = "_labeled.h5$", full.names = TRUE, recursive = TRUE)

stm(paste0("IN Labeled H5 Files  :\n\t", paste(all_labeled_h5, collapse = "\n\t")))
stm(paste0("IN JSON Files        :\n\t", paste(all_hto_json, collapse = "\n\t")))
stm(paste0("IN Multiplet H5 Files:\n\t", paste(all_multiplet_h5, collapse = "\n\t")))
stm(paste0("IN Control Labeled H5 Files:\n\t", paste(all_control_h5, collapse = "\n\t")))

```

```{r read_key}
stm("Reading in sample key")
df_key <- data.table::fread(in_key)
#setDT(control_meta)

```

```{r merge_meta}
# Merge Metadata
stm("Reading in labeled h5 file meta data")

# Merge the count matrices for all samples into 1 table
avail_workers <- as.numeric(future::availableCores())
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

meta_list <- future_lapply(all_labeled_h5, read_h5_cell_meta)
meta <- do.call(rbind, meta_list)
setDT(meta)

remove("meta_list")
```

```{r merge_well}
# Merge Well Data
stm("Reading in labeled h5 file well data")

well_list <- future_lapply(all_labeled_h5, read_h5_well_meta)
well_info <- unique(do.call(rbind, well_list))
setDT(well_info)

remove("well_list")
```  

```{r read_json}
# Read in json files
stm("Reading in hto processing metrics json files")
well_hto_json_list <- future_lapply(all_hto_json,read_hto_well_json)
well_hto_json_df <- do.call(rbind, well_hto_json_list)
well_hto_json_df <- well_hto_json_df %>% 
  dplyr::mutate(sample_hto = paste(hto_barcode, pbmc_sample_id, sep = "\n")) %>% 
  dplyr::mutate(pool_id_short = gsub(".*-", "", gsub("C.*","", well_id))) %>% 
  dplyr::mutate(pool_id = gsub("C.*","", well_id)) %>% 
  dplyr::mutate(sample_pool = paste(pbmc_sample_id, pool_id_short, sep = "_")) %>% 
  dplyr::mutate(sample_pool_hto = paste(sample_pool, hto_barcode, sep = "\n"))

remove("well_hto_json_list")
```  

```{r read_multiplet}
stm("Reading in multiplet h5 file meta data")
multiplet_meta_list <- future_lapply(all_multiplet_h5, read_h5_cell_meta)
multiplet_meta <- do.call(rbind, multiplet_meta_list)
setDT(multiplet_meta)
all_meta <- merge(meta, multiplet_meta, all = TRUE) 
  # dplyr::full_join(multiplet_meta)  # TODO: clean up formatting
remove("multiplet_meta_list","multiplet_meta")
```  

```{r read_hash}
stm("Reading in hash matrixes from labeled h5 and multiplet h5 files")
labeled_hash_list <- future_lapply(all_labeled_h5, read_h5_dgCMatrix, target = "hash")
labeled_hash <- do.call(cbind, labeled_hash_list)

multiplet_hash_list <- future_lapply(all_multiplet_h5, read_h5_dgCMatrix, target = "hash")
multiplet_hash <- do.call(cbind, multiplet_hash_list)

all_hash <- cbind(labeled_hash, multiplet_hash)

remove("labeled_hash_list","multiplet_hash_list","labeled_hash","multiplet_hash")
```  

```{r read_control}
stm("Reading in previous control labeled h5 file meta data")
control_meta_list <- future_lapply(all_control_h5, read_h5_cell_meta)
control_meta <- do.call(rbind, control_meta_list)
setDT(control_meta)

# TODO: Decide if current control should be in historical control
run_control <- meta %>%
  filter(grepl(control_sample_pattern, pbmc_sample_id))

all_control <- rbind(run_control, control_meta) %>% 
  unique()
  # dplyr::full_join(multiplet_meta)  # TODO: clean up formatting
remove("control_meta_list","control_meta")
```



```{r add_vars_meta }
meta[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
meta[, ":="(fct_mito_umi_binary = ifelse(fct_mito_umi > fct_mito_umi_threshold,
                                         paste0(">",fct_mito_umi_threshold),
                                         paste0("<=",fct_mito_umi_threshold)))]
meta[ ,pbmc_sample_pool:= sprintf("%s_%s", pbmc_sample_id, pool_id)]
meta[ ,plot_barcode:= sprintf("%s\n%s", hto_barcode, pbmc_sample_pool)]
all_meta[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
all_meta[, ":="(fct_mito_umi_binary = ifelse(fct_mito_umi > fct_mito_umi_threshold,
                                             paste0(">",fct_mito_umi_threshold),
                                             paste0("<=",fct_mito_umi_threshold)))]
all_meta[ ,pbmc_sample_pool:= sprintf("%s_%s", pbmc_sample_id, pool_id)]
all_meta[ ,plot_barcode:= sprintf("%s\n%s",hto_barcode, pbmc_sample_pool)]
all_control[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
all_control[ ,pbmc_sample_pool:= sprintf("%s_%s", pbmc_sample_id, pool_id)]
all_control[ ,plot_barcode:= sprintf("%s\n%s",hto_barcode, pbmc_sample_pool)]
```

## Batch Information    
```{r batchinfo, include = TRUE}
stm("Constructing Batch Information table")

# Summarize batch information
batch <- unique(meta$batch) # assumption is one batch per report

pools <- unique(meta$pool_id)
n_pools <- length(pools)

wells <- unique(meta$well_id)
n_wells <- length(wells)

# samples <- unique(meta$pbmc_sample_id)
samples <- unique(meta$pbmc_sample_id)
n_samples <- length(samples)

# TODO: consider using sample sheet to explicitly determine this instead

controls <- grep(control_sample_pattern, samples, value = T)
has_controls <- length(controls) > 0 

if (has_controls){
  sub_samples <- setdiff(samples, controls)
} else {
  sub_samples <- samples
}

n_sub_samples <- length(sub_samples)

samples_pool <- tapply(meta$pbmc_sample_id, meta$pool_id, unique)
samples_pool_string <- sapply(samples_pool, function(x){paste(x, collapse = ", ")})

labels <- c("Batch", "N Samples", "N Pools","N Wells","Batch Control", paste0(pools, " Samples"))
values <-  c(batch, n_sub_samples, n_pools, n_wells, has_controls, samples_pool_string)

simple_html_table(labels, values, fontsize = 3, col_widths_px = c(175, 850))

```  

```{r fig_dims}
fig_height_samples_4col <- ceiling(n_samples/4)*1.5

fig_height_samples_each_row <- n_samples*1.5

fig_width_n_pools <- n_pools*8

# fig_height_markers_3col <- ceiling(n_markers/3)*7


```  

## QC Results Summary  
```{r echo_qc_summary_chunk, ref.label = "qc_summary" }
# Placeholder for high-level summary (can't calculate everything until end)
```  

<a  id="section_top"></a>  

## Summary Details {.tabset}  

### Well Sequencing and Alignment {.active}  
  
The following metrics summarize the sequencing and alignment by 10x well prior to un-hashing and hash-based cell filtering.  
  
#### Detailed Well Summary  
```{r well_summary_table, results = "as-is"}
n_vars <- ncol(well_info)-1
varnames <- names(well_info)[-1]
digitsRound <- c(0,1,rep(0,4),rep(1,12),0,1)
names(digitsRound) <- varnames
well_info_median_range <- sapply(varnames,function(x){
  get_median_range(values = well_info[[x]], 
                   digits_round = digitsRound[x], 
                   verbose = F)
}
)
well_info_median <- lapply(well_info[,-"well_id"], median)
well_info_median_fmt <- as.character(well_info_median)
well_info_cv <- sapply(well_info[,-"well_id"], function(x){round(sd(x)/mean(x)*100,1)})

well_summary_table <- data.frame(Spec = varnames, 
                                 `Median_Range` = well_info_median_range,
                                 `Inter_Well_CV` = well_info_cv)
# well_summary_table_comments <- flag_well_summary(well_summary_table)  # Eventual function to perform well-specific flagging based on summary values
well_summary_table_comments <- well_summary_table
set.seed(1105)
dummycomments <- sample(c("","Warning: message","Fail: message"),
                        size = nrow(well_summary_table_comments), 
                        replace=T, prob = c(0.85,0.12,0.03))
well_summary_table_comments$Comments <- dummycomments
well_summary_table_comments$Plot <- sprintf("[Plot](#%s)", varnames)


well_summary_table_comments %>% 
  gt::gt() %>% 
  gt::fmt_markdown(columns = "Plot") %>% 
  gt::fmt_number(columns = vars(Inter_Well_CV), pattern = "{x}%", decimals = 1) %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.3)
      ),
    locations = cells_body(
      columns = vars(Inter_Well_CV),
      rows = Inter_Well_CV >= 10)
  ) %>% 
  gt_fmt_comments()
  # gt::tab_style(
  #   style = list(
  #     cell_fill(color = "red" , alpha = 0.3)
  #     ),
  #   locations = cells_body(
  #     columns = vars(Comments),
  #     rows = grepl("Warning",Comments))
  # ) %>% 
  # gt::tab_style(
  #   style = list(
  #     cell_fill(color = "red" , alpha = 0.5)
  #     ),
  #   locations = cells_body(
  #     columns = vars(Comments),
  #     rows = grepl("Fail",Comments))
  # ) 
  #                         

```  
  
#### Plots of Well-Level Metrics  
  
```{r well_plots, results = "asis"}
stm("Generating sequencing and alignment QC plots")

bar_theme <- function(...){
  ggplot2::theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), ...)
}
verpal <- hcl.colors(n = n_vars, palette = "viridis")

# Plots
for (i in seq_along(varnames)){
  df <- data.table::copy(well_info)
  spec <- varnames[i]
  # spec_lab <- well_spec_labels[i]
  df <- as.data.frame(df)
  df$spec_col <- df[,spec]
  med_val <- median(df$spec_col)
  cv <- round(sd(df$spec_col)/mean(df$spec_col)*100,2)
  n <- sum(!is.na(df$spec_col))
  
  g <- ggplot(df, aes(well_id, spec_col)) +
    geom_bar(stat = "identity", fill = verpal[i]) + 
    bar_theme() +
    geom_hline(yintercept = med_val, linetype = "dashed", color = "red")+
    scale_y_continuous(sec.axis = dup_axis(breaks = med_val, labels = med_val, name = ""))+
    xlab("Well") +
    ylab(spec) +
    ggtitle(sprintf("%s\nMedian=%s    CV=%.1f%%    N=%s", spec, med_val, cv, n))

  cat(sprintf('\n<a id="%s"></a>', spec), labels = "", sep = "\n")
  suppressWarnings(print(g))
  
  # cat("  ", labels = "", sep = "\n")
  cat("  \n[Return to Top](#section_top)", labels = "", sep = "\n")
  # cat(sprintf("\n[Return to Table](#%s)  ",spec), labels = "", sep = "\n")
  
  # gHist <- ggplot(df, aes(spec_col)) +
  #   geom_histogram(fill = verpal[i], bins = 10) +
  #   geom_vline(xintercept = med_val, linetype = "dashed", color = "red")+
  #   xlab(spec) +
  #   ggtitle(sprintf("%s\nMedian=%s    CV=%.1f%%    N=%s", spec, med_val, cv, n))
  # suppressWarnings(print(ggHist))
  #
  # g_grid <- cowplot::plot_grid(g, gHist, nrow = 1, rel_widths = c(4,3))
  # suppressWarnings(print(g_grid))
}

``` 
 
### Cell Hashing and Sample Quality Metrics  
<a id="top_cell_hashing"></a> 

```{r cell_hashing}
# # Merge hashing info
# hash_list <- lapply(all_labeled_h5, read_h5_dgCMatrix, target = "hash")
# names(hash_list)
# 
# h5_test <- h5dump(all_labeled_h5[[1]])
# h5test2 <- h5_list_convert_to_dgCMatrix(h5_test, target = "hash")
# hash_mat <- h5test2[["hash_dgCMatrix"]]

```  

```{r hashing_summary}
stm("Output cell hashing summary table")

dummy_blank <- rep("x",5)
dummy_table <- data.frame("Specification"=dummy_blank, 
                          "Value"= dummy_blank,
                          "Comments"=c("","","Warning: message","Fail: message",""))
dummy_table %>% 
  gt() %>% 
  gt_fmt_comments

fig_width <- n_samples*0.75

```  



#### Pool-based Summary  
```{r pool_summary}
stm("Output pool based summary table")
pool_summary <- all_meta %>% 
  group_by(hto_category, pool_id) %>% 
  summarize(n_cells = n(),
         median_reads = median(n_reads),
         median_umis = median(n_umis),
         median_genes = median(n_genes), 
         .groups = "drop") %>% 
  arrange(pool_id, hto_category)
pool_summary %>% 
  gt()
```   

<!-- #### Well-Based Summary -->
```{r well_summary}
# 
# cutoffs <- well_hto_json_df %>%
#   dplyr::group_by(hto_barcode, pbmc_sample_id, sample_hto, pool_id) %>%
#   dplyr::summarize(n_wells = n(),
#                    median_cutoff = median(cutoff),
#                    cv_cutoff = sd(cutoff)/mean(cutoff)*100)
# cutoffs
# 
# 
# well_summary <- all_meta %>% 
#   group_by(pool_id, well_id) %>% 
#   summarize(n_cells = n(),
#          median_reads = median(n_reads),
#          median_umis = median(n_umis),
#          median_genes = median(n_genes), 
#          .groups = "drop") %>% 
#   arrange(pool_id, well_id)
# well_summary %>% 
#   gt()
```  
  
#### HTO Assignment Cutoffs  

Hash detected in a well if >`r {5}` cells have any counts. Cells are called positive for a hash if counts are above the calculated cutoff.  

```{r}
temp_figwidth <- (n_pools*4 + 2.75)
```  
 
```{r hto_setup, fig.width = 6, fig.height = 30}
stm("Formating hto cutoff data")

all_meta_subset <- all_meta %>% 
  dplyr::select(barcodes, well_id, pool_id, hto_barcode, hto_category)
# log_seq <- function(from, to, length.out = 10){
#   assertthat::assert_that(from > 0)
#   assertthat::assert_that(to > 0)
# 
#   from_log <- log(from)
#   to_log <- log(to)
#   seq_log <- seq(from_log, to_log, length.out = length.out)
#   new_seq <- exp(seq_log)
#   return(new_seq)
# }


all_hash_fmt <- t(all_hash) %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column(var = "barcodes") %>% 
  gather(key = "hto", value = "count", -barcodes) %>% 
  left_join(all_meta_subset, by = "barcodes") %>% 
  left_join(well_hto_json_df, by = c("hto"="hto_barcode", "well_id"="well_id", "pool_id" = "pool_id")) %>% 
  mutate(log_count = log10(count)) %>% 
  mutate(log_count = ifelse(!is.finite(log_count),NA,log_count)) %>% # make log(0) NA
  mutate(log_cutoff = ifelse(is.na(log_count), NA,log10(cutoff))) %>% 
  dplyr::mutate(log_count_bin = cut(log_count, 
                                  breaks = seq(min(log_count,na.rm=T), max(log_count,na.rm=T), 
                                                          length.out = 30)))

# Format labels as "hash not detected" for any well/hash that has no cells with hash count >5
well_no_hash <- all_hash_fmt %>% 
  group_by(well_id, hto) %>%   # For each well/hto combinatino
  summarize(n_count = sum(count > 5),  # number of cells with hto count above min threshold
            detected = n_count > 0,  # hto  is detected if at least 1 cell has count above threshold
            .groups = "drop") %>% 
  mutate(plot_label = ifelse(detected,"","Hash not detected"))

all_hash_fmt <- all_hash_fmt %>% 
  left_join(well_no_hash, by = c("well_id" = "well_id", "hto"="hto")) %>% 
  mutate(log_count = ifelse(detected, log_count, NA)) %>%  # censor counts for plotting if overall hash not detected
  mutate(log_cutoff = ifelse(detected, log_cutoff, NA))  # censor cutoffs for plotting if overall hash not detected 

pools <- unique(all_hash_fmt$pool_id)
```  

```{r hto_ridgeplots_dim}

```

```{r hto_ridge_hist, fig.width = 10, fig.height = 8}
stm("Plotting hto count ridgeplots")

# , fig.width = 3, fig.height = 20
# Censor hto if detected in <= 5 cells in the well
for (i in seq_along(pools)){
  df <- all_hash_fmt %>% 
    filter(pool_id == pools[i]) %>% 
    # filter(count > 0) %>%   # this is the criteria to plot a hash tag in a well
    # filter(!is.na(log_count)) %>% 
    mutate(well_id = factor(well_id, levels = sort(unique(well_id))))
  
  df_lines <- df %>%
    select(well_id, sample_hto, hto, cutoff, log_cutoff) %>% 
    distinct() 
  
  detected_labels <- df %>% 
    select(well_id, hto, sample_hto, plot_label) %>% 
    distinct()
  
  g_ridge <- ggplot(df, aes(log_count, well_id)) +
    geom_segment(data = df_lines, aes(x = log_cutoff, xend = log_cutoff,
                                      y = as.numeric(well_id), yend = as.numeric(well_id)+ 0.9), color = "red") +
    ggridges::geom_density_ridges(scale = 3, stat = "binline", binwidth = 0.05, size = 0.3, aes(fill = well_id)) +  
    # ggridges::geom_density_ridges(fill = "darkgreen", scale = 3, rel_min_height = 0.01) + 
    scale_x_continuous(limits = c(-.5,max(all_hash_fmt$log_count,na.rm=T))) +
    scale_y_discrete(expand = c(0.01, 0)) +
    geom_text(data = detected_labels, x= max(all_hash_fmt$log_count,na.rm=T)/2, 
              aes(y= as.numeric(well_id),label = plot_label), 
              size = 3, vjust = 0) +
    facet_wrap(~sample_hto, ncol = 5) +
    ggtitle(pools[i]) +
    theme(axis.text.y = element_blank())
  
  # suppressMessages(plot(g_ridge))  # suppressing messages on the bandwidths selected for each facet
  plot(g_ridge)
  
}

```  


```{r hto_violin, fig.width = 10, fig.height = 8}
#stm("Plotting hto count violin plots")
# , fig.width = 3, fig.height = 20
# Censor hto if detected in <= 5 cells in the well
#for (i in seq_along(pools)){
#  df <- all_hash_fmt %>% 
#    filter(pool_id == pools[i]) %>% 
#   filter(count > 0) %>%   # this is the criteria to plot a hash tag in a well
#   mutate(well_id = factor(well_id, levels = sort(unique(well_id))))
#  
# df_lines <- df %>%
#    select(well_id, sample_hto, hto, cutoff, log_cutoff) %>% 
#    distinct() 
#  
#  g_violin <- ggplot(df, aes(well_id, log_count)) +
#    # geom_segment(data = df_lines, aes(y = log_cutoff, yend = log_cutoff,
#    #                                   x = well_id, xend = well_id), color = "red") +
#    geom_violin(aes(fill = well_id)) +
#    geom_point(data = df_lines, aes(x = well_id, y = log_cutoff), shape = "-", color = "red", size = 5) +
#    scale_y_continuous(limits = c(-.5,max(all_hash_fmt$log_count,na.rm=T))) +
#    geom_text(y= max(all_hash_fmt$log_count,na.rm=T)/2, 
#              aes(x= as.numeric(well_id),label = plot_label), 
#              size = 3, hjust = 0.5, angle = 90, check_overlap = T) +
#    facet_wrap(~sample_hto, ncol = 5) +
#    ggtitle(pools[i]) +
#    theme(axis.text.x = element_text(angle = 90))
#  
#  # suppressMessages(plot(g_ridge))  # suppressing messages on the bandwidths selected for each facet
#  plot(g_violin)
 # 
#}

```  


```{r hto_densityplots, fig.width = 6, fig.height = 12}
#stm("Plotting hto count density plots")
# Censor hto if detected in <= 5 cells in the well
#for (i in seq_along(pools)){
#  df <- all_hash_fmt %>% 
#    filter(pool_id == pools[i]) %>% 
#    filter(count > 0) %>%   # this is the criteria to plot a hash tag in a well
#    mutate(well_id = factor(well_id, levels = sort(unique(well_id))))
#  
#  g_density <- ggplot(df, aes(log_count)) +
#    geom_vline(aes(xintercept = log_cutoff, color = well_id)) +
#    geom_density(aes(color = well_id)) +
#    facet_wrap(~sample_hto, ncol=1, scales = "free_y") +
#    ggtitle(pools[i])
#  plot(g_density)
#}

```  


```{r hto_heatmap, fig.width = 6, fig.height = 40}
#stm("Plotting hto count heatmap plots")
#all_hash_fmt_scale <- all_hash_fmt %>% 
#  group_by(well_id, pool_id, hto, log_count_bin) %>% 
#  summarize(N = n(),.groups = "drop") %>% 
#  ungroup() %>% 
#  group_by(well_id, hto) %>% 
#  mutate(mean_group = mean(N),
#         sd_group = sd(N),
#         scaled_n = (N - mean_group)/sd_group) %>% 
#  ungroup() %>% 
#  as.data.frame() %>% 
#  filter(!is.na(log_count_bin))

#for (i in seq_along(pools)){
#  g_heatmap <- ggplot(all_hash_fmt_scale %>% filter(pool_id == pools[i]), 
#                      aes(x = log_count_bin, y = factor(well_id), fill = scaled_n))+
#    geom_tile() +
#    facet_grid(hto ~ .,drop = TRUE, switch = "y") +
#    scale_fill_gradientn(colours = c("darkblue","green", "yellow","orange","red","darkred"), na.value = "black") +
#    scale_y_discrete(position = "right") 
#  plot(g_heatmap) 
#}
```  
  
[Return to Top](#top_cell_hashing) 
  
```{r hto_assignment, fig.height = 6, fig.width = temp_figwidth, class.output = "superbigimage"}
stm("Plotting hto cutoff boxplots")
g_cutoff_box <- ggplot(well_hto_json_df, aes(sample_hto, cutoff, color = hto_barcode)) +
  suppressWarnings(geom_point(alpha = 0.4, position = position_jitter(height = 0, width = 0.3, seed = 20201112),
             aes(text = sprintf("Well ID: %s",  well_id)))) +
  geom_boxplot(alpha = 0, outlier.alpha = 1, color = "black") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        axis.title.x = element_text(margin = margin(c(15,0,1,0)))) +
  facet_grid(~pool_id, drop = TRUE, scales = "free_x")+
  ggtitle("Well-Specific HTO Cutoffs") 

ply_cutoff_box <- plotly::ggplotly(g_cutoff_box) 
ply_cutoff_box %>% 
  add_axis_title_spacing_plotly("x", n_lines = 4) %>% 
  add_axis_title_spacing_plotly("y", n_lines = 2)

```  
  
[Return to  Top](#top_cell_hashing)  
  
```{r hto_pos_cutoff, fig.width = temp_figwidth, fig.height = 6}
stm("Plotting hto positive call box plots")
g_cutoff_pos <- ggplot(well_hto_json_df, aes(sample_hto, frac_pos, color = hto_barcode)) +
  suppressWarnings(geom_point(alpha = 0.4, position = position_jitter(height = 0, seed = 20201112),
             aes(text = sprintf("Well ID: %s",  well_id)))) +
  geom_boxplot(alpha = 0, outlier.alpha = 1, color = "black") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
                axis.title.x = element_text(margin = margin(c(15,0,1,0)))) +
  facet_grid(~pool_id, drop = TRUE, scales = "free_x")+
  ggtitle("Fraction Positive HTO Calls per Well")
ply_cutoff_pos <- plotly::ggplotly(g_cutoff_pos) 
ply_cutoff_pos %>% 
  add_axis_title_spacing_plotly("x", n_lines = 4) %>% 
  add_axis_title_spacing_plotly("y", n_lines = 2)
```  
  
[Return to Top](#top_cell_hashing)  
    
 
#### HTO Category Counts by Well  

```{r hto_cat_counts, out.width=fig_width_n_pools, fig.height = 7}
stm("Plotting hto category counts per well")
# hto_cat <- all_meta %>% 
#   group_by(well_id, pool_id, hto_category) %>% 
#   summarise(N = n(), .groups = "drop") %>% 
#   tidyr::spread(key = hto_category, value = N) 
  
qc_aligned_barplot_mod(all_meta,
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "hto_category",
                   category_name = "HTO Category",
                   colorset_y = "varibow",
                   name_y = "N Cells",
                   padding = 0.2, 
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_x") +
  ggtitle("HTO Category Counts per Well")
  
```  
  
[Return to Top](#top_cell_hashing)  
  
    
#### HTO Category Fraction by Well  

```{r hto_cat_fractions, out.width=fig_width_n_pools, fig.height = 6}
stm("Plotting hto category fraction per well")

# hto_cat <- all_meta %>% 
#   group_by(well_id, pool_id, hto_category) %>% 
#   summarise(N = n(), .groups = "drop") %>% 
#   tidyr::spread(key = hto_category, value = N) 
qc_stacked_barplot_mod(all_meta,
                       category_x = "well_id",
                       name_x = "Well ID",
                       category_y = "hto_category",
                       category_name = "HTO Category",
                       colorset_y = "varibow",
                       name_y = "Fraction of Cells",
                       as_fraction = TRUE, facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_x") +
  ggtitle("HTO Category Counts per Well")

  
```

[Return to Top](#top_cell_hashing)

#### Singlet Summaries (hash-based)  

##### HTO Barcode Count per Well Plot  

```{r hto_counts_well,  fig.width = fig_width_n_pools, fig.height = 6, class.output = "superbigimage"}
stm("Plotting barcode count per well and hto")

plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_aligned_barplot_mod(meta = meta[meta$pool_id == pools[i]],
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "plot_barcode",
                   category_name = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   padding = 0.2) +#,
                   # facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_y", drop = TRUE) +
  ggtitle(pools[i])

}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)

```   
  
[Return to Top](#top_cell_hashing)  
  
##### HTO Barcode Fraction per Well Plot  

```{r hto_fraction_well,  fig.width = fig_width_n_pools, fig.height = 6}
stm("Plotting barcode fraction per well and hto")

plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_stacked_barplot_mod(meta = meta[pool_id==pools[i]],
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "plot_barcode",
                   category_name = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   as_fraction = TRUE, 
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_x") +
  ggtitle("HTO Barcode Fraction per Well")+
    theme(text = element_text(size = 12))
}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)
  
```  
  
[Return to Top](#top_cell_hashing)  
  
##### Well Count per HTO Barcode Plot  

```{r Well Count By HTO Barcode Plot, fig.height = 6, fig.width = fig_width_n_pools}
stm("Plotting well count per hto")

plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_aligned_barplot_mod(meta = meta[pool_id == pools[i],],
                   category_x = "plot_barcode",
                   category_y = "well_id",
                   category_name = "Well ID",
                   name_x = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales ="free_x", drop = TRUE) +
  ggtitle("Well Fraction per HTO Barcode")
}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)


```  
  
[Return to Top](#top_cell_hashing)  
  
##### Well Fraction per HTO Barcode Plot  
```{r Well Fraction By HTO Barcode Plot, fig.height = 6, fig.width = fig_width_n_pools}
stm("Plotting well fraction per hto")

plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_stacked_barplot_mod(meta = meta[pool_id == pools[i],],
                   category_x = "plot_barcode",
                   category_y = "well_id",
                   category_name = "Well ID",
                   name_x = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   as_fraction = TRUE , 
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales ="free_x", drop = TRUE) +
  ggtitle("Well Fraction per HTO Barcode")
}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)

```  
  
[Return to Top](#top_cell_hashing)  
  
##### Counts by HTO Category and Barcode  
```{r read_counts, height = 5, width = 12}
# Reads per hto cat
stm("Generating read count violin plots")
category_reads_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_reads",
                                         name_y = "N Reads per Cell",
                                         fill = "dodgerblue")
# Reads per hto plot
g_read <- qc_violin_plot(meta,
                        category_x = "plot_barcode",
                        name_x = "HTO Barcode (singlets)",
                        column_y = "n_reads",
                        name_y = "N Reads per Cell",
                        log_y = TRUE,
                        fill = "dodgerblue") +
  ggtitle("Reads per Cell")
# g_read

reads_violin_list <- list(category_reads_violins, 
                          g_read)
plot_grid(plotlist = reads_violin_list,
          ncol = 2, rel_widths = c(1, 4),
          nrow = 1, align = "h")
``` 
  
[Return to Top](#top_cell_hashing)  
  
```{r umi_counts}
# UMI per category plot
stm("Generating umi count violin plots")
category_umis_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_umis",
                                         name_y = "N UMIs per Cell",
                                         fill = "purple")


# UMI per cell plot
g_umi <- qc_violin_plot(meta,
                        category_x = "plot_barcode",
                        name_x = "HTO Barcode (singlets)",
                        column_y = "n_umis",
                        name_y = "N UMIs per Cell",
                        fill = "purple") +
  ggtitle("UMIs per Cell")
# g_umi


umis_violin_list <- list(category_umis_violins, 
                          g_umi)
plot_grid(plotlist = umis_violin_list,
          ncol = 2, rel_widths = c(1, 4),
          nrow = 1, align = "h")

```   
  
[Return to Top](#top_cell_hashing)  
  
```{r gene_counts }
# Genes per category plot
category_genes_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_genes",
                                         name_y = "N Genes per Cell",
                                         fill = "orangered")
# Genes per cell plot
g_genes <- qc_violin_plot(meta,
                        category_x = "plot_barcode",
                        name_x = "HTO Barcode (singlets)",
                        column_y = "n_genes",
                        name_y = "N Genes per Cell",
                        fill = "orangered") +
  ggtitle("Genes per Cell")


genes_violin_list <- list(category_genes_violins, 
                          g_genes)
plot_grid(plotlist = genes_violin_list,
          ncol = 2, rel_widths = c(1, 4),
          nrow = 1, align = "h")

``` 
  
[Return to Top](#top_cell_hashing)  
  
```{r pct_mito}
meta$fct_mito_group <- cut(meta$fct_mito_umi, breaks = c(-Inf, 0.05, 0.10, 0.20, 0.30,Inf), labels = c("0-0.05","0.05-0.10","0.10-0.20","0.20-0.30",">0.30"))
# ggplot(meta, aes(pbmc_sample_id, fct_mito_umi, color = fct_mito_umi > 0.5)) +
#   geom_point(alpha = 0.2,position = position_jitter(height = 0, width = 0.3, seed = 1)) +
#   geom_boxplot(color = "black", alpha = 0 , outlier.alpha = 1) +
#   scale_y_log10()

g_bar <- ggplot(meta, aes(pbmc_sample_pool,  fill = fct_mito_group))+
  geom_bar() +
  labs(fill = "Fraction Mitochondrial UMIs") +
  ylab("N Cells") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) 
plotly::ggplotly(g_bar) %>%
layout(hovermode = 'compare')

```   
  
[Return to Top](#top_cell_hashing)  
  
```{r combine count matrices for all samples}
stm("Reading and merging all count matrices")

# Set up for multithreading
avail_workers <- as.numeric(future::availableCores())
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

# Merge the count matrices for all samples into 1 table
all_counts_list <- future.apply::future_lapply(all_labeled_h5, H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
# all_counts_list <- lapply(all_labeled_h5, H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
all_counts_mat <- do.call(cbind, all_counts_list)
all_counts_cells_bc <- meta$original_barcodes

featDF <- read_h5_feature_meta(all_labeled_h5[1])

# rm("all_counts_list")
```  
```{r seurat_normalize}
# Create Seurat object
stm("Creating Seurat object from merged data")
merged_so <- Seurat::CreateSeuratObject(counts = all_counts_mat)

# Normalize data
stm("Normalizing data")
future::plan("sequential")  # reverting to sequential to avoid error
merged_so <- Seurat::NormalizeData(object = merged_so, 
                                   normalization.method = "LogNormalize",
                                   scale.factor = 10000,
                                   margin = 1)

normCounts <- merged_so[["RNA"]]@data

```  

```{r PCA}
pc_dims <- min(ncol(merged_so) - 1, 50)

stm("Finding Variable Features")
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
merged_so <- FindVariableFeatures(object = merged_so)

stm("Scaling Data")
future::plan("sequential")  # reverting to sequential to avoid error
merged_so <- ScaleData(object = merged_so, verbose = FALSE)

stm("Running PCA")
merged_so <- RunPCA(object = merged_so, npcs = pc_dims, verbose = FALSE)  

# save pca object
# saveRDS(merged_so, file = "merged_so_pcaresults.rds")
# merged_so <- readRDS("merged_so_pcaresults.rds")
 
```  

```{r jackstraw_pc_selection, message = FALSE}
stm("Determining dimensionality via jackstraw method")
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
sample_cells <- function(cl, 
                          sample.size, 
                          seed = 3030) {
  cl.cells <- split(names(cl), cl)
  sampled.cells <- sapply(names(cl.cells), function(x) {
    cells <- cl.cells[[x]]
    if (sample.size >= length(cells)) {
      return(cells)
    }
    to.sample <- pmin(sample.size, length(cells))
    
    set.seed(seed)
    sample(cells, to.sample)
  }, simplify = FALSE)
  sampled.cells <- unlist(sampled.cells)
  return(sampled.cells)
}

labels_order <- meta$seurat_pbmc_type[match(meta$barcodes, colnames(merged_so))]
names(labels_order) <- colnames(merged_so)

jackstraw_cells <- sample_cells(labels_order, 100, seed = 3030)

jackstraw_so <- merged_so[,jackstraw_cells]

jackstraw_so <- JackStraw(object = jackstraw_so,
                         dims = pc_dims,
                         num.replicate = 50,  #  increase to 96 if run on 96 core?
                         verbose = FALSE)
jackstraw_so <- ScoreJackStraw(object = jackstraw_so,
                              dims = 1:pc_dims)

pc_pvals <- jackstraw_so@reductions$pca@jackstraw$overall.p.values[,2]
good_pcs <- pc_pvals < 0.05

nPC <- sum(good_pcs)

pc_var <- Stdev(merged_so, reduction = "pca")^2
total_var <- merged_so@reductions$pca@misc$total.variance
var_selected_pc <- sum(pc_var[good_pcs])/total_var
cumvar_string <- sprintf(fmt = "%.1f", var_selected_pc*100)

stm(sprintf("Selected %s significant pcs via JackStraw, %s explained variation", nPC, cumvar_string))

pc_embeddings <- merged_so@reductions$pca@cell.embeddings

# stm(sprintf("Using %s principal components for umap",nPC))
```  

```{r}
# nPC <-  50
# 
# pc_var <- Stdev(merged_so, reduction = "pca")^2
# total_var <- merged_so@reductions$pca@misc$total.variance
# var_selected_pc <- sum(pc_var)/total_var
# cumvar_string <- sprintf(fmt = "%.1f", var_selected_pc*100)
# 
# stm(sprintf("Selected %s pcs, %s explained variation", nPC, cumvar_string))
# 
# pc_embeddings <- merged_so@reductions$pca@cell.embeddings
# 
# stm(sprintf("Using %s principal components for umap",nPC))
```  

```{r merged_umap}
# Run UMAP
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
stm(sprintf("Running UMAP on selected coordinates. Using %s cores", nbrOfWorkers()))
## As the number of dimensions, use the same PCs as input to the clustering analysis

merged_so <- Seurat::RunUMAP(merged_so,
                                   dims = c(1:50)[good_pcs],
                                   # umap.method = "umap-learn",
                                   umap.method = "uwot",
                                   seed.use = 3,
                                   verbose = FALSE)
saveRDS(merged_so, file = "merged_so.Rds")
future::plan("sequential")
```

```{r cell_cylce}
#stm("Determining Cell Cycle Scoring")

#s.genes <- Seurat::cc.genes$s.genes
#g2m.genes <- Seurat::cc.genes$g2m.genes
#merged_so <- CellCycleScoring(merged_so, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)

```

```{r recover_analysis }
# merged_so <- readRDS("~/Packages/scrna-batch-report/inst/rmarkdown/merged_so_elbow.Rds")
# merged_so_elbow <- readRDS("merged_so_elbow.Rds")
```


```{r umap_cleanup}
# Get UMAP coordinates
umapDF <- merged_so[["umap"]]@cell.embeddings %>%
          as.data.frame() %>%
          dplyr::rename(UMAP_1_merged = UMAP_1, UMAP_2_merged = UMAP_2) %>%
          tibble::rownames_to_column(var = "barcodes")
umapDF <- merge(umapDF, meta, by = "barcodes")
rownames(umapDF) <- umapDF$barcodes
umapDF <- umapDF[rownames(merged_so@"meta.data"), , drop = F]

normCounts <- merged_so[["RNA"]]@data
if(!all(rownames(umapDF) == colnames(normCounts))){
  stop("Merged UMAP dataframe does not match columns in normalized counts")
}

```   

#### Data Quality UMAP  

Batch-level UMAP using `r {nPC}` principal components (`r {cumvar_string}`% explained variance).  

```{r umap_quality,  results = "asis", fig.height = 30, fig.width = 20, class.output = "superbigimage"}
stm("Plotting Batch UMAP by Data Quality Metrics")

# Gene scaling
# min_genes <- min(100, meta$n_genes)
max_genes <- max(8000, meta$n_genes)
max_umi <- max(60000, meta$n_umis)
point_size <- 0.2

# df <- umapDF
# x_col <- "UMAP_1_merged"
# y_col <- "UMAP_2_merged"
# color_col = "fct_mito_umi"
# scale_color_fun <- scale_color_gradientn

plot_umap_report <- function(df, x_col, x_lab, y_col, y_lab, title, point_size, color_col, scale_color_fun,...){
  g <- ggplot(df, aes_string(x_col, y_col)) + 
    geom_point(alpha = 1, size = point_size, aes_string(color = color_col)) +
    ggtitle(title)+
    xlab(x_lab) +
    ylab(y_lab) +
    scale_color_fun() +
    theme_bw() +
    theme(aspect.ratio = 1/1,
          text = element_text(size = 20))
  return(g)
  
} 

scale_color_genes <- function(max_genes){
  function(...){
    scale_color_gradientn(limits = c(0, max_genes),
                          colours = c("blue","deepskyblue","green3", "yellow","orange","red","darkred"),
                          values = scales::rescale(c(0,500, 1000, 2000, 3000, 4000, max_genes),
                                                   from = c(0, max_genes)),
                          breaks = c(0,2000,4000,6000,8000), ...)
  }
}

scale_color_umis <- function(max_umi){
  function(...){
    scale_color_gradientn(limits = c(0, max_umi),
                          colours = c("blue","deepskyblue","green3", "yellow","orange","red","darkred"),
                          values = scales::rescale(c(0,1000, 3000, 5000, 7500, 10000, max_umi),
                                                   from = c(0, max_umi)), ...)
  }
}

scale_color_fct_mito <- function(...){
  scale_color_gradientn(limits = c(0,1),
                       colors = c("blue", "green3","yellow","red"), 
                       breaks = c(0,0.25,0.5,0.75,1),...)
  
  
}

# theme_gradient <- 

# Cell Types
g_base <- ggplot(umapDF, aes(UMAP_1_merged, UMAP_2_merged)) 

# fraction mitochondrial umi
stm("Plotting Fraction Mito UMAP")
g3 <- plot_umap_report(df = umapDF,
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "Fraction Mitochondrial UMIs",
                 point_size = point_size,
                 color_col = "fct_mito_umi",
                 scale_color_fun = scale_color_fct_mito)
# g3 <- g_base +
#   geom_point(alpha = 1, size = point_size, aes(color = fct_mito_umi)) +
#   ggtitle("Fraction Mitochondrial UMIs")+
#   scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
#                         breaks = c(0,0.25,0.5,0.75,1)) +
#   theme_bw() +
#   theme(aspect.ratio = 1/1,
#         title = element_text(size = 20))


# N Genes
stm("Plotting N Genes UMAP")
g4 <- plot_umap_report(df = umapDF, 
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "N Genes",
                 point_size = point_size,
                 color_col = "n_genes",
                 scale_color_fun = scale_color_genes(max_genes)
)

# g4 <- g_base +
#   geom_point(alpha = 1, size = point_size, aes(color = n_genes)) +
#   ggtitle("Gene Counts")+
#   scale_color_gradientn(limits = c(0, max_genes),
#                         colours = c("blue","deepskyblue","green3", "yellow","orange","red","darkred"),
#                         values = scales::rescale(c(0,500, 1000, 2000, 3000, 4000, max_genes),
#                                                  from = c(0, max_genes)),
#                         breaks = c(0,2000,4000,6000,8000)) +
#   theme_bw() +
#   theme(aspect.ratio = 1/1,
#         title = element_text(size = 20))

# N UMIs
stm("Plotting N UMIs UMAP")
g5 <- plot_umap_report(df = umapDF, 
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "N UMIs",
                 point_size = point_size,
                 color_col = "n_umis",
                 scale_color_fun = scale_color_umis(max_umi)
)


# g5 <- g_base +
#   geom_point(alpha = 1, size = point_size, aes(color = n_umis)) +
#   ggtitle("UMI Counts")+
#   scale_color_gradientn(limits = c(0,max_umi),
#                         colours = c("blue","deepskyblue","green3", "yellow","orange","red","darkred"),
#                         values = scales::rescale(c(0,1000, 3000, 5000, 7500, 10000, max_umi),
#                                                  from = c(0, max_umi))) +
#   theme_bw() +
#   theme(aspect.ratio = 1/1,
#         title = element_text(size = 20))

# Wells
stm("Plotting Well UMAP")
cols_well <- immutils::varibow(n_colors = length(unique(umapDF$well_id)))
# g6 <- g_base +
#   geom_point(alpha = 1, size = point_size, aes(color = well_id)) +
#   ggtitle("Well ID") +
#   scale_color_manual(values = cols_well)+
#   theme_bw() +
#   theme(aspect.ratio = 1/1,
#         title = element_text(size = 20),
#         legend.key.size = unit(1, 'lines')) +
#   guides(colour = guide_legend(override.aes = list(size = 3)))

scale_color_well <- function(...){
    scale_color_manual(values = cols_well, ...)
}
g6 <- plot_umap_report(df = umapDF, 
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "Well ID",
                 point_size = point_size,
                 color_col = "well_id",
                 scale_color_fun = scale_color_well
)

# Sample
stm("Plotting Sample ID UMAP")
cols_sample <- immutils::varibow(n_colors = length(unique(umapDF$pbmc_sample_id)))
scale_color_sample <- function(...){
    scale_color_manual(values = cols_sample, ...)
}
# g7 <- g_base +
#   geom_point(alpha = 1, size = point_size, aes(color = pbmc_sample_id)) +
#   ggtitle("Sample ID")+
#   scale_color_manual(values = cols_sample) + 
#   theme_bw()+
#   theme(aspect.ratio = 1/1,
#         title = element_text(size = 20),
#         legend.key.size = unit(1, 'lines'),
#         legend.text = element_text(size = 12)) +
#   guides(colour = guide_legend(override.aes = list(size = 3)))

g7 <- plot_umap_report(df = umapDF, 
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "Sample ID",
                 point_size = point_size,
                 color_col = "pbmc_sample_id",
                 scale_color_fun = scale_color_sample
)


aligned_plots <- cowplot::align_plots(g3, g4, g5, g6, g7, align = "hv", axis = "tblr")  # uniform plot sizing 

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   aligned_plots[[3]],
                   aligned_plots[[4]],
                   aligned_plots[[5]],
                   ncol = 2)

```  
  
[Return to Top](#top_cell_hashing)  


### Cell Labeling  

<a id="top_cell_labeling"></a> 

```{r cell_labeling_summary}
sample_info <- meta %>% 
  group_by(pbmc_sample_id, pool_id) %>% 
  summarize(n_cells = n(),
            n_fct_mito_gt50 = sum(fct_mito_umi>0.5),
            n_fct_mito_lte50 = sum(fct_mito_umi<=0.5),
            median_label_score = median(seurat_pbmc_type_score),
            .groups = "drop") %>% 
  ungroup() %>% 
  mutate(fct_cells_fct_mito_gt.5 = n_fct_mito_gt50/n_cells)


dummy_table %>% 
  gt() %>% 
  gt_fmt_comments()

```  
  
   
#### Seurat Labeling Scores  

```{r cell_labeling, fig.height = 8, fig.width = 20}
stm("Plotting Seurat labeling score distributions")

cell_type_palette <- data.frame(
  seurat3_pbmc_type = c("B cell progenitor", "CD14+ Monocytes", "CD16+ Monocytes",
                       "CD4 Memory", "CD4 Naive","CD8 effector", "CD8 Naive", 
                       "Dendritic cell", "Double negative T cell", "NK cell",
                       "pDC", "Platelets", "pre-B cell"),
  cell_color = c("#FF0000","#FF8C00","#FFEE00","#44FF00", "#00E1FF","#0000FF",
                 "#E546FA","#F598E5","#008A12", "#803CCF", "#967729", "#B1C4F0",
                 "#DCF0B1"), 
  stringsAsFactors = FALSE
)

# quality scores by sample
# meta_sample <- meta[ ,.(median_quality = median(seurat_pbmc_type_score)), by = pbmc_sample_id]

meta_label <- meta[ ,.(median_quality = median(seurat_pbmc_type_score)), by = seurat_pbmc_type]
meta_label[, median_quality_label := sprintf("median = %.3f", round(median_quality,3))]

ggplot(meta, aes(seurat_pbmc_type_score, fill = seurat_pbmc_type)) +
  geom_histogram(bins = 30) +
  scale_color_discrete() +
  geom_text(data = meta_label, x = -Inf, y = Inf, hjust = -0.1, vjust = 1.5, size = 7, aes(label = median_quality_label))+
  ggtitle("Label Quality Score by Cell Label Type") +
  xlab("Label Score") +
  facet_wrap( ~ seurat_pbmc_type, ncol= 1) +
  scale_fill_manual(values = cell_type_palette$cell_color, labels = cell_type_palette$seurat3_pbmc_type) +
  theme_bw() +
  theme(title = element_text(size = 24), 
        legend.text = element_text(size = 18),
        strip.text = element_text(size = 20, face = "bold"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 20))+
  facet_wrap(~seurat_pbmc_type, scales = "free_y")

```  
    
[Return to Top](#top_cell_labeling)  

#### UMAP All Cells  

Batch-level UMAP using `r {nPC}` principal components (`r {cumvar_string}`% explained variance).  

```{r umap_labels,  results = "asis", fig.height = 10, fig.width = 20, class.output = "superbigimage"}
# Gene scaling
max_genes <- max(8000,meta$n_genes)
max_umi <- max(60000,meta$n_umis)
point_size <- 0.2

# Cell Types
g_base <- ggplot(umapDF, aes(UMAP_1_merged, UMAP_2_merged)) 

stm("Plotting cell type UMAP")
g1 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = seurat_pbmc_type)) +
  ggtitle("Cell Labels")+
  scale_color_manual(values = cell_type_palette$cell_color, 
                     breaks = cell_type_palette$seurat3_pbmc_type) +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20), 
        legend.key.size = unit(1, 'lines'),
        legend.text = element_text(size = 14)) + 
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Labeling Scores
stm("Plotting Labeling Score UMAP")
g2 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = seurat_pbmc_type_score)) +
  ggtitle("Label Scores")+
  scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
                        breaks = c(0,0.25,0.5,0.75,1)) +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))


aligned_plots <- cowplot::align_plots(g1, g2, align = "hv", axis = "tblr")  # uniform plot sizing 

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   ncol = 2)

```

[Return to Top](#top_cell_labeling) 


#### UMAP by Fraction Mitochondrial UMI
  
Removed `r {sum(umapDF$fct_mito_umi >= fct_mito_umi_threshold)}` cells (`r {round(sum(umapDF$fct_mito_umi >= fct_mito_umi_threshold)/nrow(umapDF)*100,1)}`%)

```{r cell_labeling_lowmito, fig.height = 20, fig.width = 20}
stm("Plotting Batch UMAP labeling, by fraction mitochondrial reads")
g1_mito <- g1 +
  facet_grid(~fct_mito_umi_binary) +
  ggtitle("Cell Labels by Fraction Mitochondrial UMI")+
  theme(strip.text = element_text(size = 18))

# Labeling Scores
stm("Plotting Batch UMAP labeling scores, by fraction mitochondrial reads")
g2_mito <- g2 +
  facet_grid(~fct_mito_umi_binary) +
  ggtitle("Cell Label Scores by Fraction Mitochondrial UMI")+
  theme(strip.text = element_text(size = 18))

aligned_plots <- cowplot::align_plots(g1_mito, g2_mito, align = "hv", axis = "tblr")  # uniform plot sizing 

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   ncol = 1)

```

[Return to Top](#top_cell_labeling)  

```{r cell_labeling_mito_celltypes, fig.height = 10, fig.width = 20}
stm("Plotting Batch UMAP labeling scores, by fraction mitochondrial reads")
summaryScores <- umapDF %>%
  group_by()


label_scores_mito <- function(umapDF, mito_binary = "fct_mito_umi_binary"){
  summary_all <- umapDF %>%
    group_by(seurat_pbmc_type) %>%
    summarize(N = n(), .groups = "drop") %>%
    ungroup() %>%
    mutate(pct = N/sum(N)) %>%
    mutate(group = "All")

  label_order <- names(sort(table(summary_all$seurat_pbmc_type), decreasing = TRUE))

  summary_split <- umapDF %>%
    group_by(seurat_pbmc_type, !!rlang::parse_expr(mito_binary)) %>%
    summarize(N = n(), .groups = "drop") %>%
    ungroup() %>%
    group_by(!!rlang::parse_expr(mito_binary)) %>%
    mutate(pct = N/sum(N) ) %>%
    rename(group = !!mito_binary) %>%
    mutate(group = paste0("FractionMT",group))

  summary_merge <- rbind(summary_all, summary_split) %>%
    mutate(seurat_pbmc_type = factor(seurat_pbmc_type, levels = label_order))

  ggplot(summary_merge, aes(factor(seurat_pbmc_type, levels = label_order), pct, fill = group))+
    geom_bar(stat = "identity", position = "dodge")
}

label_scores_mito(umapDF)

```
  
#### Marker Visualization  
  
```{r marker_umap,fig.height = 35, fig.width = 25,  class = "superbigimage"}
stm("Plotting UMAP of marker genes")
genes <- c("CD3D","CD3E", "CD3G","CD247","CD4", "CD8A", 
            "HLA-DRA", "CD14", "FCGR3A", "IL3RA", "ITGAX", 
           "CD19", "MS4A1", "CD79A", "NCAM1", "NKG7", "PPBP", "IL7R",
           "FUT4", "ITGAM","FCGR2B","FCER1A")
cDF <- normCounts
# rownames(cDF) <- featDF$name[featDF$id == rownames(cDF)]

# Add normalized gene counts to the analysis dataframe (UMAP + meta)
markerDF <- t(cDF[genes, ]) %>% as.data.frame()
umapDF2 <- umapDF[, c("UMAP_1_merged", "UMAP_2_merged","fct_mito_umi")]
# table(rownames(markerDF) == rownames(umapDF2))
umapDF2 <- cbind(umapDF2, markerDF) %>% 
  tidyr::gather(key = gene, value = value, -UMAP_1_merged, -UMAP_2_merged) 
umapDF2$gene <- factor(umapDF2$gene, levels = genes)

# plot UMAP per marker
marker_umap_l <- list()
for(G in genes) {
  umapDF3 <- umapDF2 %>% dplyr::filter(gene %in% G)
  marker_umap_l[[G]] <- ggplot(data = umapDF3,
                               mapping = aes(x = UMAP_1_merged, 
                                             y = UMAP_2_merged, 
                                             color = as.numeric(value))) +
    geom_point(size = 0.8) +
    scale_color_gradient(low = "white", high = "red") +
    labs(x = "UMAP 1", y = "UMAP 2") +
    labs(color = "NormCount") +
    ggtitle(G)+
    theme(aspect.ratio = 1/1,
          panel.background = element_rect(fill = "#b6b7b2"),
          plot.title = element_text(size = 20),
          axis.text.x = element_text(size = 12, color = "black"),
          axis.text.y = element_text(size = 12, color = "black"),
          axis.line = element_line(color = "grey"),
          panel.grid = element_blank())
}



cowplot::plot_grid(plotlist = marker_umap_l, ncol = 3)

```  

[Return to Top](#top_cell_labeling)   
  
### Leukopak Control  

<a id="top_control"></a> 

```{r control_summary}
all_control <- all_control %>% 
  mutate(control_type = ifelse(batch_id == batch, "new", "reference")) 
by_control <- all_control %>% 
  group_by(control_type) %>% 
  summarize(n_cells = n(),
            median_reads = median(n_reads),
            median_umi = median(n_umis),
            median_genes = median(n_genes),
            .groups = "drop")
# by_control

dummy_table %>% 
  gt() %>% 
  gt_fmt_comments()

```  

```{r control_label_counts}
lab_order <- sort(table(all_control$seurat_pbmc_type[all_control$control_type=="reference"]), decreasing = TRUE)
all_control <- all_control %>% 
  mutate(seurat_pbmc_type = factor(seurat_pbmc_type, levels = names(lab_order)))

ctrl_by_type <- all_control %>% 
  group_by(control_type, seurat_pbmc_type) %>% 
  summarize(N = n(), .groups = "drop") %>% 
  ungroup() %>% 
  group_by(control_type) %>% 
  mutate(pct = N/sum(N)*100) %>% 
  arrange(-pct) %>% 
  mutate(seurat_pbmc_type = factor(seurat_pbmc_type, levels = unique(seurat_pbmc_type)))

qc_aligned_barplot(meta=all_control, category_x = "seurat_pbmc_type", name_x = "Cell Label",
                   category_y = "control_type", name_y = "N Cells",colorset_y = "rainbow", category_name = "control_type")

# ggplot(all_control, aes(factor(seurat_pbmc_type, levels = levels(ctrl_by_type$seurat_pbmc_type)))) +
#   geom_bar(aes(fill = control_type)) +
#   theme(axis.text.x = element_text(angle = 90)) +
#   facet_wrap(~control_type, nrow = 2) +
#   ggtitle("Count Cell Types") +
#   ylab("N All Cells") +
#   xlab("Cell Label") +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
#         text = element_text(size = 12))
```    

[Return to Top](#top_control)   

```{r control_pct_counts, fig.width = 10, class.output = "superbigimage"}
g <- ggplot(ctrl_by_type, aes(seurat_pbmc_type, y = pct)) +
  geom_bar(aes(fill = control_type), position = "dodge", stat = "identity")  +
  ggtitle("Percent Cells by Label") +
  ylab("Percent All Cells") +
  xlab("\n\n\n\n\n\nCell Label") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.title.x = element_text(margin = margin(20,0,0,0))) 
ggplotly(g) %>% 
  layout(hovermode = "compare")%>% layout(legend = list(x = 0.8, y = 0.9))


```  

[Return to Top](#top_control)   
  
```{r umap_control}
stm("Reading and merging all control count matrices")
# Merge the count matrices for all samples into 1 table
avail_workers <- as.numeric(future::availableCores())
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

run_ctrl_h5 <- grep(control_sample_pattern, all_labeled_h5, value = TRUE)
combined_control_h5 <- c(run_ctrl_h5, all_control_h5)
all_ctrl_list <- future.apply::future_lapply(all_control_h5, H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
all_ctrl_mat <- do.call(cbind, all_ctrl_list)
all_ctrl_cells_bc <- all_control$original_barcodes


featDF_ctrl <- read_h5_feature_meta(combined_control_h5[1])

# Confirm that features are same between control 
all_same_features <- do.call(all.equal,lapply(all_ctrl_list, row.names))
if(!all_same_features){
  stop("All batch control samples do not have the same features")
}

```   

```{r seurat_normalize_ctrl}
# Create Seurat object
stm("Creating Seurat object from merged data")
ctrl_so <- Seurat::CreateSeuratObject(counts = all_ctrl_mat)

# Normalize data
stm("Normalizing data")
plan("sequential")  # reverting to sequential to avoid error
ctrl_so <- Seurat::NormalizeData(object = ctrl_so, 
                                 normalization.method = "LogNormalize",
                                 scale.factor = 10000,
                                 margin = 1)

normCountsctrl <- ctrl_so[["RNA"]]@data

```


```{r PCA_ctrl}
pc_dims_ctrl <- min(ncol(ctrl_so) - 1, 50)

stm("Finding Variable Features Control")

ctrl_so <- FindVariableFeatures(object = ctrl_so)

stm("Scaling Data Control")
ctrl_so <- ScaleData(object = ctrl_so, verbose = FALSE)

stm("Running PCA Control")
ctrl_so <- RunPCA(object = ctrl_so, npcs = pc_dims_ctrl, verbose = FALSE)  

# save pca object
# saveRDS(ctrl_so, file = "ctrl_so_pcaresults.rds")
# ctrl_so <- readRDS("ctrl_so_pcaresults.rds")

```  


```{r Jackstraw_ctrl, message = FALSE}
stm("Determining dimensionality via jackstraw method control")

sample_cells <- function(cl, 
                          sample.size, 
                          seed = 3030) {
  cl.cells <- split(names(cl), cl)
  sampled.cells <- sapply(names(cl.cells), function(x) {
    cells <- cl.cells[[x]]
    if (sample.size >= length(cells)) {
      return(cells)
    }
    to.sample <- pmin(sample.size, length(cells))
    
    set.seed(seed)
    sample(cells, to.sample)
  }, simplify = FALSE)
  sampled.cells <- unlist(sampled.cells)
  return(sampled.cells)
}

labels_order_ctrl <- all_control$seurat_pbmc_type[match(all_control$barcodes,colnames(ctrl_so))]
names(labels_order_ctrl) <- colnames(ctrl_so)

jackstraw_cells_ctrl <- sample_cells(labels_order_ctrl, 100)
jackstraw_so_ctrl <- ctrl_so[,jackstraw_cells_ctrl]

jackstraw_so_ctrl <- JackStraw(object = jackstraw_so_ctrl, 
                          dims = pc_dims, 
                          num.replicate = 50,  #  increase to 96 if run on 96 core?
                          verbose = FALSE)
jackstraw_so_ctrl <- ScoreJackStraw(object = jackstraw_so_ctrl, 
                               dims = 1:pc_dims)

pc_pvals_ctrl <- jackstraw_so_ctrl@reductions$pca@jackstraw$overall.p.values[,2]
good_pcs_ctrl <- pc_pvals_ctrl < 0.05

pc_embeddings_ctrl <- ctrl_so@reductions$pca@cell.embeddings

nPC_ctrl <- sum(good_pcs_ctrl)

pc_var_ctrl <- Stdev(ctrl_so, reduction = "pca")^2
total_var_ctrl <- ctrl_so@reductions$pca@misc$total.variance
var_selected_pc_ctrl <- sum(pc_var_ctrl[good_pcs_ctrl])/total_var_ctrl
cumvar_string_ctrl <- sprintf(fmt = "%.1f", var_selected_pc_ctrl*100)

stm(sprintf("Selected %s significant pcs via jackstraw, %s explained variation", nPC_ctrl, cumvar_string_ctrl))
```

Batch Control UMAP using `r {nPC_ctrl}` principal components (`r {cumvar_string_ctrl}`% explained variance).  

```{r merged_umap_ctrl}
# Run UMAP
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
stm("Running UMAP on selected coordinates...")
## As the number of dimensions, use the same PCs as input to the clustering analysis

ctrl_so <- Seurat::RunUMAP(ctrl_so,
                                   dims = c(1:50)[good_pcs_ctrl],
                                   # umap.method = "umap-learn",
                                   umap.method = "uwot",
                                   seed.use = 3,
                                   verbose = FALSE)
# saveRDS(ctrl_so_elbow, file = "ctrl_so_elbow.Rds")

future::plan("sequential")
```


```{r umap_cleanup_ctrl}
# Get UMAP coordinates
umapDF_ctrl <- ctrl_so[["umap"]]@cell.embeddings %>%
          as.data.frame() %>%
          dplyr::rename(UMAP_1_merged = UMAP_1, UMAP_2_merged = UMAP_2) %>%
          tibble::rownames_to_column(var = "barcodes")
umapDF_ctrl <- merge(umapDF_ctrl, all_control, by = "barcodes")
rownames(umapDF_ctrl) <- umapDF_ctrl$barcodes
umapDF_ctrl <- umapDF_ctrl[rownames(ctrl_so@"meta.data"), , drop = F]

normCountsctrl <- ctrl_so[["RNA"]]@data
if(!all(rownames(umapDF_ctrl) == colnames(normCountsctrl))){
  stop("Merged controls UMAP dataframe does not match columns in normalized counts")
}

```   

```{r umap_quality_ctrl,  results = "asis", fig.height = 20, fig.width = 20, class.output = "superbigimage"}
stm("Plotting Control UMAP by Data Quality Metrics")

# Gene scaling
# min_genes <- min(100, meta$n_genes)
max_genes <- max(8000,all_control$n_genes)
max_umi <- max(60000,all_control$n_umis)
point_size <- 0.4

# Cell Types
g_base <- ggplot(umapDF_ctrl %>% arrange(desc(control_type)), aes(UMAP_1_merged, UMAP_2_merged)) 


stm("Plotting cell type UMAP")
g1 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = seurat_pbmc_type)) +
  ggtitle("Cell Labels")+
  scale_color_manual(values = cell_type_palette$cell_color, 
                     breaks = cell_type_palette$seurat3_pbmc_type) +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20), 
        legend.key.size = unit(1, 'lines'),
        legend.text = element_text(size = 14)) + 
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Labeling Scores
stm("Plotting Labeling Score UMAP")
g2 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = seurat_pbmc_type_score)) +
  ggtitle("Label Scores")+
  scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
                        breaks = c(0,0.25,0.5,0.75,1)) +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))

# Control Type
stm("Plotting Control type UMAP")
g3 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = control_type)) +
  ggtitle("Control Type")+
  theme_bw()+
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.key.size = unit(1, 'lines'),
        legend.text = element_text(size = 14)) +
  guides(colour = guide_legend(override.aes = list(size = 3)))

aligned_plots <- cowplot::align_plots(g1, g2,g3, align = "hv", axis = "tblr")  # uniform plot sizing 

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   aligned_plots[[3]],
                   ncol = 2)


```  

[Return to Top](#top_control)   


<!-- Batch Summary QC Executed here, referenced in "echo_qc_summary_chunk" above to allow display in first tab -->
```{r qc_summary, results = "hide"}
# qcCriteria <- c("Cells per Well, Count [Median (Range)]", "Cells per Well, Variation [CV]")
# qcCriteriaLevel <- c("Well", "Well")
# qcValues <- c("31239 [12312-4153151]", "34.5%")


qcCriteria <- c("Well Sequencing and Alignment", "Cell Hashing", "Cell Labeling", "Control Sample")
qcMessage <- c("Warning", "Pass", "Pass", "Pass")

final_qc <- data.table(Category = qcCriteria, 
                       Results = qcMessage,
                       Description = "                      ")

final_qc %>% 
  gt::gt() %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.3)
      ),
    locations = cells_body(
      columns = vars(Results),
      rows = grepl("Warning",Results))
  ) %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.5)
      ),
    locations = cells_body(
      columns = vars(Results),
      rows = grepl("Fail",Results))
  ) 

```  



### Session Information 
<a id="top_session_info"></a>  

Files Analyzed:  
```{r echo_files}
all_files_bn <- basename(all_labeled_h5)
all_files_bn

all_hto_json_bn <- basename(all_hto_json)
all_hto_json_bn

all_multiplet_bn <- basename(all_multiplet_h5)  
all_multiplet_bn  

```

Session Info:  
```{r Session Info}
sessionInfo()
```

Total time elapsed
```{r Show Time}
end_time <- Sys.time()
diff_time <- end_time - start_time
time_message <- paste0("Elapsed Time: ", 
                       round(diff_time, 3),
                       " ", units(diff_time))
print(time_message)
stm(time_message)
stm("Batch report process complete.")
```  

[Return to Top](#top_session_info)

# {.tabset}
