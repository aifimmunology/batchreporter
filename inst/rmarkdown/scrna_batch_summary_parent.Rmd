---
title: "scRNA Seq Batch Summary: `r {params$batch}`"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    self_contained: true
  tables: yes
params:
  batch: "X002"
  in_dir: NULL
  in_key: NULL
  in_batch_meta: NULL
  in_config: NULL 
  out_dir: NULL
  n_cores: NULL
  mc_mb_limit: 50000
---

<!-- create details section to collapse multiple no-output code blocks to save space -->
<details style="color: lightgray;"> 
  <summary>Expand Code</summary> 

```{r}
scrna_batch_label_parent_version <- "1.0.1" # 20211006 

```
  
```{r setup, include = TRUE}
# Load Libraries
start_time <- Sys.time()

options(warn = 1)  # output warnings as they appear for traceability in stdout/stderr record

knitr::opts_chunk$set(echo = TRUE, warning = FALSE) # warnings will go to console

quiet_library <- function(...) {
  suppressPackageStartupMessages(library(...))
}

quiet_library(Matrix)        # dependency of H5weaver
quiet_library(rhdf5)         # dependency of H5weaver
quiet_library(H5weaver)      # aifi package
quiet_library(HTOparser)     # aifi package
quiet_library(ggplot2)       
quiet_library(dplyr)         # data wrangling
quiet_library(cowplot)       # arranging multiple plots
quiet_library(gt)            # formatted table output
quiet_library(plotly)        # interactive plots
quiet_library(tidyr)         # data wrangling
quiet_library(Seurat)        # batch umap creation
quiet_library(future)        # multi-threading for batch umap creation
quiet_library(future.apply)  # multi-threading for batch umap creation

stm(paste(c("\t",paste(names(Sys.info()),Sys.info(),sep = ": ")), collapse = "\n\t"))
```  

```{css style_definitions}
# Allow display of large images without shrinking to page width
<style>
  .superbigimage{
      overflow-x:scroll;
  }

  .superbigimage img{
     max-width: none;
  }

</style>
    
```  


```{r parse_arguments}
# give input directory rna-specific name 
if(is.null(params$in_dir)) {
  batch <- "X002"
  rna_in_dir <- "/batchreporter/inst/extdata/X002"
  in_key <- "/batchreporter/inst/extdata/example_sample_key_X002.csv"
  in_config <- "/batchreporter/inst/extdata/default_rna_config_v1.csv"
  in_batch_meta <- "/batchreporter/inst/extdata/batch-metadata.json"
  out_dir <- tempdir()
} else {
  batch <-  params$batch
  rna_in_dir <- params$in_dir
  in_key <- params$in_key
  in_config <- params$in_config
  if(is.null(in_config)){
      in_config <- "/batchreporter/inst/extdata/default_rna_config_v1.csv"
      stm("No config file provided. Using default_rna_config_v1.csv for pbmc data")
  }
  out_dir <- params$out_dir
  in_batch_meta <- params$in_batch_meta
  if(is.null(in_batch_meta)){in_batch_meta <- NA}
}

# Memory limit for mc processing. Default futures is 500
if(is.null(params$mc_mb_limit)){
  par_mb_limit <- 50000  # Default futures setting is 500, too low for most batches
} else {
  par_mb_limit <- params$mc_mb_limit
}
options('future.globals.maxSize' = par_mb_limit*1024^2)

# N cores for mc processing
if(is.null(params$n_cores)) {
  avail_workers <- as.numeric(future::availableCores()-2)
  if (avail_workers < 1){
    avail_workers <- 1
  }
} else {
  avail_workers <- params$n_cores 
}

stm(paste0("IN Batch        : ", batch))
stm(paste0("IN Directory    : ", rna_in_dir))
stm(paste0("IN Sample Key   : ", in_key))
stm(paste0("IN Batch Processing Info   : ", in_batch_meta))
stm(paste0("Multiple Cores  : ", avail_workers))
stm(paste0("Mb Memory for MC: ", par_mb_limit))
stm(paste0("OUT Dir         : ", out_dir))
```  


```{r variable_definitions}
cnfg <- load_config(in_config)
expected_parameters <- c("fct_mito_umi_threshold",
                         "sample_column_name",
                         "hash_key",
                         "cell_label_column_name",
                         "cell_label_score_column_name",
                         "cell_label_method",
                         "genes_plot",
                         "s.genes",
                         "g2m.genes")
validate_config(cnfg, expected_parameters)

fct_mito_umi_threshold <- cnfg$fct_mito_umi_threshold
sample_column_name <- cnfg$sample_column_name
cell_label_column_name <- cnfg$cell_label_column_name
cell_label_score_column_name <- cnfg$cell_label_score_column_name
cell_label_method <- cnfg$cell_label_method
cell_label_reference <- cnfg$cell_label_reference
hash_key <- cnfg$hash_key
genes_plot <- cnfg$genes_plot
s.genes <- cnfg$s.genes
g2m.genes <- cnfg$g2m.genes

# fct_mito_umi_threshold <- 0.10
# sample_column_name <- "pbmc_sample_id"
# genes_plot <- c("CD3D","CD3E", "CD3G","CD247","CD4", "CD8A",
#                 "HLA-DRA", "CD14", "FCGR3A", "IL3RA", "ITGAX",
#                 "CD19", "MS4A1", "CD79A", "NCAM1", "NKG7", "PPBP", "IL7R",
#                 "FUT4", "ITGAM","FCGR2B","FCER1A")
# cell_label_column_name <- "seurat_pbmc_type"
# cell_label_score_column_name <- "seurat_pbmc_type_score"
# cell_label_method <- "Seurat3-PBMC"
# 
# s.genes <- Seurat::cc.genes.updated.2019$s.genes
# g2m.genes <- Seurat::cc.genes.updated.2019$g2m.genes

```  

```{r find_rna_files}
# Get list of all target files
all_labeled_h5 <- list.files(path = file.path(rna_in_dir,"labeled_h5"), 
                             pattern = "_labeled.h5$", 
                             full.names = TRUE, 
                             recursive = TRUE)
all_hto_json <- list.files(path = file.path(rna_in_dir,"hash"), 
                           pattern = "hto_processing_metrics.json$", 
                           full.names = TRUE, 
                           recursive = TRUE)
all_multiplet_h5 <- list.files(path = file.path(rna_in_dir,"multiplet_h5"), 
                               pattern = "multiplet.h5$", 
                               full.names = TRUE, 
                               recursive = TRUE)
all_control_h5 <- list.files(path = file.path(rna_in_dir,"control"), 
                             pattern = "_labeled.h5$", 
                             full.names = TRUE, 
                             recursive = TRUE)

stm(paste0("IN Labeled H5 Files  :\n\t", paste(all_labeled_h5, collapse = "\n\t")))
stm(paste0("IN JSON Files        :\n\t", paste(all_hto_json, collapse = "\n\t")))
stm(paste0("IN Multiplet H5 Files:\n\t", paste(all_multiplet_h5, collapse = "\n\t")))
stm(paste0("IN Control Labeled H5 Files:\n\t", paste(all_control_h5, collapse = "\n\t")))

```

```{r read_key, include = FALSE}
stm("Reading in sample key")
df_key <- data.table::fread(in_key)
has_controls <- any(grepl("Control", df_key$Type))  # used to control evaluation of batch control-related code chunks

assertthat::assert_that(length(unique(df_key$BatchID)) == 1, msg = "More than 1 batch in input sample key file")
assertthat::assert_that(batch == unique(df_key$BatchID), msg = "Batch in input key file does not match input batch value")

```

```{r merge_meta}
# Merge Metadata
stm("Reading in labeled h5 file meta data")

# Merge the count matrices for all samples into 1 table
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

meta_list <- future_lapply(all_labeled_h5, read_h5_cell_meta)

# Create metadata table that contains only singlet cells
meta <- dplyr::bind_rows(meta_list)
setDT(meta)

remove("meta_list")
```

```{r read_multiplet}  
# Create meta data table that includes missing hashes and multiplet data
stm("Reading in multiplet h5 file meta data")
multiplet_meta_list <- future_lapply(all_multiplet_h5, read_h5_cell_meta)

multiplet_meta <- dplyr::bind_rows(multiplet_meta_list)
setDT(multiplet_meta)

# Create metadata table that contains both singlet and multiplet cells
all_meta <- merge(meta, multiplet_meta, all = TRUE) 
remove("multiplet_meta_list","multiplet_meta")
```  
  
```{r add_vars_meta }
stm("Adding analysis variables to meta data tables")

# Mito UMI variables and compound labels for plotting
meta[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
meta[, ":="(fct_mito_umi_binary = ifelse(fct_mito_umi > fct_mito_umi_threshold,
                                         paste0(">",fct_mito_umi_threshold),
                                         paste0("<=",fct_mito_umi_threshold)))]
meta[ , sample_pool:= sprintf("%s_%s", get(sample_column_name), pool_id)]
meta[ , sample_pool:= factor(sample_pool, levels = unique(sample_pool[order(pool_id, get(sample_column_name))]))]
meta[ , fct_mito_group:=cut(fct_mito_umi, breaks = c(-Inf, 0.05, 0.10, 0.20, 0.30,Inf),
                           labels = c("0-0.05","0.05-0.10","0.10-0.20","0.20-0.30",">0.30"))]

# Mito UMI variables and compound labels for plotting
all_meta[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
all_meta[, ":="(fct_mito_umi_binary = ifelse(fct_mito_umi > fct_mito_umi_threshold,
                                             paste0(">",fct_mito_umi_threshold),
                                             paste0("<=",fct_mito_umi_threshold)))]
all_meta[ , sample_pool:= sprintf("%s_%s", get(sample_column_name), pool_id)]
all_meta[ , sample_pool:= factor(sample_pool, levels = unique(sample_pool[order(pool_id, get(sample_column_name))]))]

```

```{r read_control, eval = has_controls}
# This chunk only evaluated if controls present in samplesheet
stm("Reading in previous control labeled h5 file meta data")

if(has_controls){
  controls <- unique(df_key$SampleID[df_key$Type == "Control"])

  new_control_h5 <- grep(paste(controls, collapse = "|"), all_labeled_h5, value = TRUE)
  all_control_h5 <- c(all_control_h5, new_control_h5)
}

control_meta_list <- future_lapply(all_control_h5, read_h5_cell_meta)

meta_cols_keep <- c("barcodes", "batch_id", "cell_name", "cell_uuid", "chip_id", "hto_barcode", "hto_category", "n_genes", 
                    "n_mito_umis", "n_reads", "n_umis", "original_barcodes", sample_column_name, "pool_id", cell_label_column_name, 
                    cell_label_score_column_name, "well_id")
control_meta_list <- future_lapply(control_meta_list, function(x){x[, meta_cols_keep]})

all_control <- do.call(rbind, control_meta_list)
setDT(all_control)

remove("control_meta_list")

all_control[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
all_control[ , sample_pool:= sprintf("%s_%s", get(sample_column_name), pool_id)]
all_control[ , plot_barcode:= sprintf("%s\n%s",hto_barcode, sample_pool)]

```  
</details>  
<!-- end of details section collapsing multiple no-output code blocks to save space -->

## Batch Information    
```{r batchinfo, include = TRUE}
stm("Constructing Batch Information table")

# Summarize batch information, also declare some global batch variables that are used throughout the report
pools <- unique(df_key$PoolID)
n_pools <- length(pools)

wells <- unlist(strsplit(unique(df_key$WellID), split = ";"))
n_wells <- length(wells)

samples <- unique(df_key$SampleID)
n_samples <- length(samples)

controls <- unique(df_key$SampleID[df_key$Type == "Control"])
control_string <- ifelse(has_controls, paste(controls, collapse = ", "), "None")

if (has_controls){
  n_study_samples <- setdiff(samples, controls)
} else {
  n_study_samples <- samples
}

n_study_samples <- length(n_study_samples)

samples_pool <- tapply(df_key$SampleID, df_key$PoolID, unique)
samples_pool_string <- sapply(samples_pool, function(x){paste(x, collapse = ", ")})

labels <- c("Batch", "N Samples", "N Pools","N Wells","Batch Control", paste0(pools, " Samples"))
values <-  c(batch, n_study_samples, n_pools, n_wells, control_string, samples_pool_string)

simple_html_table(labels, values, fontsize = 3, col_widths_px = c(175, 850))

```  

## Data Processing  
```{r display_processing_details, results = "asis"}
if(!is.na(in_batch_meta)){
  if(!file.exists(in_batch_meta)) {stop(sprintf("Supplied in_batch_meta file '%s' does not exist. ",in_batch_meta))}
  meta_table <- jsonlite::read_json(in_batch_meta)
  meta_table <- as.data.frame(meta_table)  # collapses any nested names
  
  if(nrow(meta_table) == 1){
    simple_html_table(colnames(meta_table), unlist(meta_table[1,]), fontsize = 3, col_widths_px = c(200,250))
  } else{
    stop(sprintf("in_batch_meta file should have 1:1 key value pairs. Check supplied file '%s' for proper formatting. ",in_batch_meta))
  }
} else {
  cat("No processing details supplied")
}
```   

<a  id="section_top"></a>  

## Summary Details {.tabset}  

<a  id="rna_seq_top"></a> 

### Well Sequencing and Alignment {.active}  

```{r scrna_seq_child, child = "/batchreporter/inst/rmarkdown/scrna_seq_module.Rmd"}

```
  
### Cell Hashing 

```{r scrna_hashing_child, child = "/batchreporter/inst/rmarkdown/scrna_hashing_module.Rmd"} 

```


### Quality Metrics  

<a id="top_quality_metrics"></a>  

Metrics shown for all singlet cells post un-hashing.  

#### Contents 

##### [Fraction Mitochondrial Reads](#fraction_mito_reads)
##### [Data Quality UMAP](#data_quality_umap)

<a id="fraction_mito_reads"></a>

#### Fraction Mitochondrial Reads

```{r pct_mito, results = "asis"}
meta$fct_mito_group <- cut(meta$fct_mito_umi, breaks = c(-Inf, 0.05, 0.10, 0.20, 0.30,Inf),
                           labels = c("0-0.05","0.05-0.10","0.10-0.20","0.20-0.30",">0.30"))

g_bar <- ggplot(meta, aes(sample_pool,  fill = fct_mito_group))+
  geom_bar() +
  labs(fill = "Fraction Mitochondrial UMIs") +
  ylab("N Cells") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

g_pl <- plotly::ggplotly(g_bar) %>%
  layout(hovermode = 'compare')

tempwidth <- n_samples*0.4 + 2

make_subchunk(g_pl, subchunk_name = "fraction_mito_subchunk", quiet_knit = T,
              chunk_opt_list = list(fig.width = tempwidth, fig.height = 6))

```

[Return to Top](#top_quality_metrics)

<!-- create details section to collapse multiple no-output code blocks to save space -->
<details style="color: lightgray;"> 
  <summary>Expand Code</summary> 

```{r combine count matrices for all samples}
stm("Reading and merging all count matrices")

# Set up for multithreading
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

# Merge the count matrices for all samples into 1 table
all_counts_list <- future.apply::future_lapply(all_labeled_h5, H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
all_counts_mat <- do.call(cbind, all_counts_list)
all_counts_cells_bc <- meta$original_barcodes

featDF <- read_h5_feature_meta(all_labeled_h5[1])

rm("all_counts_list")
```

```{r seurat_normalize}
# Create Seurat object
stm("Creating Seurat object from merged data")
merged_so <- Seurat::CreateSeuratObject(counts = all_counts_mat)

# Normalize data
stm("Normalizing data")
merged_so <- Seurat::NormalizeData(object = merged_so,
                                   normalization.method = "LogNormalize",
                                   scale.factor = 10000,
                                   margin = 1)

normCounts <- merged_so[["RNA"]]@data

```

```{r PCA}
pc_dims <- min(ncol(merged_so) - 1, 50)
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

stm("Finding Variable Features")
merged_so <- FindVariableFeatures(object = merged_so)

stm("Scaling Data")
merged_so <- ScaleData(object = merged_so, verbose = FALSE)

stm("Running PCA")
merged_so <- RunPCA(object = merged_so, npcs = pc_dims, verbose = FALSE)

```

```{r jackstraw_pc_selection, message = FALSE}
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

stm("Determining dimensionality via jackstraw method")

labels_order <- meta[,get(cell_label_column_name)][match(meta$barcodes, colnames(merged_so))]
names(labels_order) <- colnames(merged_so)

jackstraw_cells <- sample_cells(labels_order, 100, seed = 3030)

jackstraw_so <- merged_so[,jackstraw_cells]

jackstraw_so <- JackStraw(object = jackstraw_so,
                         dims = pc_dims,
                         num.replicate = 50,  #  increase to 96 if run on 96 core?
                         verbose = FALSE)
jackstraw_so <- ScoreJackStraw(object = jackstraw_so,
                              dims = 1:pc_dims)

pc_pvals <- jackstraw_so@reductions$pca@jackstraw$overall.p.values[,2]
good_pcs <- pc_pvals < 0.05

nPC <- sum(good_pcs)

pc_var <- Stdev(merged_so, reduction = "pca")^2
total_var <- merged_so@reductions$pca@misc$total.variance
var_selected_pc <- sum(pc_var[good_pcs])/total_var
cumvar_string <- sprintf(fmt = "%.1f", var_selected_pc*100)

stm(sprintf("Selected %s significant pcs via JackStraw, %s%% explained variation", nPC, cumvar_string))

pc_embeddings <- merged_so@reductions$pca@cell.embeddings

# stm(sprintf("Using %s principal components for umap",nPC))
```

```{r merged_umap}
# Run UMAP
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
stm(sprintf("Running UMAP on selected coordinates"))

merged_so <- Seurat::RunUMAP(merged_so,
                                   dims = c(1:50)[good_pcs],
                                   umap.method = "uwot",
                                   seed.use = 3,
                                   verbose = FALSE)

```

```{r cell_cycle}
stm("Determining Cell Cycle Scoring")

merged_so <- CellCycleScoring(merged_so, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)

df_cc <- merged_so[[]][,c("S.Score", "G2M.Score","Phase")] %>%
    tibble::rownames_to_column("barcodes")
```


```{r umap_cleanup}
# Get UMAP coordinates
umapDF <- merged_so[["umap"]]@cell.embeddings %>%
          as.data.frame() %>%
          dplyr::rename(UMAP_1_merged = UMAP_1, UMAP_2_merged = UMAP_2) %>%
          tibble::rownames_to_column(var = "barcodes")
umapDF <- merge(umapDF, meta, by = "barcodes")
umapDF <- merge(umapDF, df_cc, by = "barcodes")
rownames(umapDF) <- umapDF$barcodes

umapDF <- umapDF[rownames(merged_so@"meta.data"), , drop = F]

normCounts <- merged_so[["RNA"]]@data
if(!all(rownames(umapDF) == colnames(normCounts))){
  stop("Merged UMAP dataframe does not match columns in normalized counts")
}

```

</details>  
<!-- end of details section collapsing multiple no-output code blocks to save space -->  

<a id="data_quality_umap"></a>  

#### Data Quality UMAP

Batch-level UMAP using `r {nPC}` principal components (`r {cumvar_string}`% explained variance) selected by jackstraw.

```{r umap_quality,  results = "asis", fig.height = 30, fig.width = 20, class.output = "superbigimage"}
stm("Plotting Batch UMAP by Data Quality Metrics")

# Gene scaling
max_genes <- max(8000, meta$n_genes)
max_umi <- max(60000, meta$n_umis)
point_size <- 0.2


# Cell Types
g_base <- ggplot(umapDF, aes(UMAP_1_merged, UMAP_2_merged))

# fraction mitochondrial umi
stm("Plotting Fraction Mito UMAP")
g3 <- plot_umap_report(df = umapDF,
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "Fraction Mitochondrial UMIs",
                 point_size = point_size,
                 color_col = "fct_mito_umi",
                 scale_color_fun = scale_color_fct_mito)

# N Genes
stm("Plotting N Genes UMAP")
g4 <- plot_umap_report(df = umapDF,
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "N Genes",
                 point_size = point_size,
                 color_col = "n_genes",
                 scale_color_fun = scale_color_genes(max_genes)
)

# N UMIs
stm("Plotting N UMIs UMAP")
g5 <- plot_umap_report(df = umapDF,
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "N UMIs",
                 point_size = point_size,
                 color_col = "n_umis",
                 scale_color_fun = scale_color_umis(max_umi)
)


# Wells
stm("Plotting Well UMAP")
cols_well <- H5weaver::varibow(n_colors = length(unique(umapDF$well_id)))

scale_color_well <- function(...){
    scale_color_manual(values = cols_well, ...)
}
g6 <- plot_umap_report(df = umapDF,
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "Well ID",
                 point_size = point_size,
                 color_col = "well_id",
                 scale_color_fun = scale_color_well
) +
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Sample
stm("Plotting Sample ID UMAP")
cols_sample <- H5weaver::varibow(n_colors = length(unique(umapDF[,sample_column_name])))
scale_color_sample <- function(...){
    scale_color_manual(values = cols_sample, ...)
}

g7 <- plot_umap_report(df = umapDF,
                 x_col="UMAP_1_merged",
                 x_lab = "UMAP 1",
                 y_col = "UMAP_2_merged",
                 y_lab = "UMAP 2",
                 title = "Sample ID",
                 point_size = point_size,
                 color_col = sample_column_name,
                 scale_color_fun = scale_color_sample
) +
  guides(colour = guide_legend(override.aes = list(size = 3)))


aligned_plots <- cowplot::align_plots(g3, g4, g5, g6, g7, align = "hv", axis = "tblr")  # uniform plot sizing

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   aligned_plots[[3]],
                   aligned_plots[[4]],
                   aligned_plots[[5]],
                   ncol = 2)

```

[Return to Top](#top_quality_metrics)


### Cell Labeling  

<a id="top_cell_labeling"></a>

#### Labeling Method: `r {sprintf("%s, %s", cell_label_method, cell_label_reference)}`

#### Contents 
##### [Labeling Scores](#labeling_scores)
##### [UMAP All Cells](#umap_all_cells)
##### [UMAP by Fraction Mitochondrial UMI](#umap_fct_mito_umi)
##### [Cell Type by Fraction Mitochondrial UMI](#celltype_fct_mito_umi)
##### [Fraction Mitochondrial UMI by Cell Type](#group_fct_mito_umi_bycelltype)
##### [Marker Visualization](#marker_visualization)

<a id="labeling_scores"></a>

#### Labeling Scores

```{r cell_labeling, fig.height = 8, fig.width = 20}
stm("Plotting Seurat labeling score distributions")

# load cell color palette
cell_labels <- unique(meta[,get(cell_label_column_name)])
cell_type_palette <- get_cell_label_palette(cell_label_method = cell_label_method,
                                                           cell_labels = cell_labels)
                                                            
# quality scores by sample
meta_label <- meta[ ,.(median_quality = median(get(cell_label_score_column_name))), by = cell_label_column_name]
meta_label[, median_quality_label := sprintf("median = %.3f", round(median_quality,3))]

ggplot(meta, aes(get(cell_label_score_column_name), fill = get(cell_label_column_name))) +
  geom_histogram(bins = 30) +
  scale_color_discrete() +
  geom_text(data = meta_label, x = -Inf, y = Inf, hjust = -0.1, vjust = 1.5, size = 7, aes(label = median_quality_label))+
  ggtitle("Label Quality Score by Cell Label Type") +
  xlab("Label Score") +
  scale_fill_manual(values = cell_type_palette$cell_color, 
                    labels = cell_type_palette$cell_labels,
                    name = cell_label_column_name) +
  theme_bw() +
  theme(title = element_text(size = 24),
        legend.text = element_text(size = 18),
        strip.text = element_text(size = 20, face = "bold"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 20))+
  facet_wrap(~get(cell_label_column_name), scales = "free_y")

```

[Return to Top](#top_cell_labeling)  

<a id="umap_all_cells"></a>

#### UMAP All Cells

Batch-level UMAP using `r {nPC}` principal components (`r {cumvar_string}`% explained variance) selected by jackstraw.

```{r umap_labels,  results = "asis", fig.height = 12, fig.width = 20, class.output = "superbigimage"}
point_size <- 0.2

# Cell Types
g_base <- ggplot(umapDF, aes(UMAP_1_merged, UMAP_2_merged))

stm("Plotting cell type UMAP")

g1 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = get(cell_label_column_name))) +
  ggtitle("Cell Labels")+
  scale_color_manual(values = cell_type_palette$cell_color,
                     breaks = cell_type_palette$cell_labels,
                     name = "Cell Label") +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.key.size = unit(1, 'lines'),
        legend.text = element_text(size = 14)) +
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Labeling Scores
stm("Plotting Labeling Score UMAP")
g2 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = get(cell_label_score_column_name))) +
  ggtitle("Label Scores")+
  scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
                        breaks = c(0,0.25,0.5,0.75,1), 
                        name = "Label Score") +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))

stm("Plotting G1 Cell Cycle Category UMAP")
g3  <- ggplot(umapDF %>% dplyr::filter(Phase == "G1"), aes(UMAP_1_merged, UMAP_2_merged))  +
  geom_point(alpha = 0.3, size = point_size, color = "blue") +
  ggtitle("G1 Cells")+
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))

stm("Plotting S Cell Cycle Category UMAP")
g4  <- ggplot(umapDF %>% dplyr::filter(Phase == "S"), aes(UMAP_1_merged, UMAP_2_merged))  +
  geom_point(alpha = 0.3, size = point_size, color = "forestgreen") +
  ggtitle("S Cells")+
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))

stm("Plotting G2M Cell Cycle Category UMAP")
g5  <- ggplot(umapDF %>% dplyr::filter(Phase == "G2M"), aes(UMAP_1_merged, UMAP_2_merged))  +
  geom_point(alpha = 0.3, size = point_size, color = "orange") +
  ggtitle("G2M Cells")+
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))

aligned_plots <- cowplot::align_plots(g1, g2, g3, g4, g5, align = "hv", axis = "tblr")  # uniform plot sizing

```  

```{r umap_labels_output,  results = "asis", fig.height = 6, fig.width = 20, class.output = "superbigimage"}
cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   ncol = 2)

```  

<details>
    <summary> Expand Cell Cycle UMAP plots </summary>

```{r umap_cell_cycle,  results = "asis", fig.height = 12, fig.width = 20, class.output = "superbigimage"}

cowplot::plot_grid(aligned_plots[[3]],
                   aligned_plots[[4]],
                   aligned_plots[[5]],
                   ncol = 2)

```  
</details>

[Return to Top](#top_cell_labeling)  

<a id="umap_fct_mito_umi"></a>  

#### UMAP by Fraction Mitochondrial UMI  

```{r fct_mito_table}

mito_tab <- umapDF %>% 
  group_by(fct_mito_umi_binary) %>% 
  summarize(N_cells = n(),
            .groups = "drop") %>% 
  mutate(Pct_cells = N_cells/sum(N_cells)*100) %>% 
  rename(fraction_mt_umi_group = fct_mito_umi_binary)
     
gt(mito_tab)             

```  

```{r cell_labeling_lowmito, fig.height = 20, fig.width = 20}
stm("Plotting Batch UMAP labeling, by fraction mitochondrial reads")
g1_mito <- g1 +
  facet_grid(~fct_mito_umi_binary) +
  ggtitle("Cell Labels by Fraction Mitochondrial UMI")+
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  theme(strip.text = element_text(size = 18))

# Labeling Scores
stm("Plotting Batch UMAP labeling scores, by fraction mitochondrial reads")
g2_mito <- g2 +
  facet_grid(~fct_mito_umi_binary) +
  ggtitle("Cell Label Scores by Fraction Mitochondrial UMI")+
  theme(strip.text = element_text(size = 18))

aligned_plots <- cowplot::align_plots(g1_mito, g2_mito, align = "hv", axis = "tblr")  # uniform plot sizing

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   ncol = 1)

```

[Return to Top](#top_cell_labeling)  

<a id="celltype_fct_mito_umi"></a>  

#### Cell Types by Fraction Mitochondrial UMI Group  

```{r celltype_piechart_bymito_group, fig.width = 8, fig.height = 3.8}
stm("Plotting cell type umi picharts by fraction mitochondrial umi group")

# create df with mt groups + all cells
mito_all <- umapDF %>%
    select(barcodes, all_of(cell_label_column_name),fct_mito_umi_binary) %>%
    mutate(group = "All cells") %>%
    mutate(facet_group = get(cell_label_column_name))
mito_groups <- umapDF %>%
    select(barcodes, all_of(cell_label_column_name),fct_mito_umi_binary) %>%
    mutate(group = paste0("FractionMT",fct_mito_umi_binary)) %>%
    mutate(facet_group = get(cell_label_column_name))
mito_plot <- rbind(mito_all, mito_groups) %>%
    group_by(group, !!rlang::parse_expr(cell_label_column_name)) %>%
    summarize(N = n(), .groups = "drop") %>%
    ungroup() %>%
    group_by(group) %>%
    mutate(Pct = N/sum(N)*100) %>%
    ungroup()

g_pie1 <- qc_piechart(meta = mito_plot, 
       category_y = cell_label_column_name, 
       category_name = "Cell Type", 
       stat = "identity", 
       variable_y_identity = "N",
       palette_df_group = cell_type_palette,
       label_size = 2, 
       plot_font_size = 14,
       nudge_x_label = 0.2,
       facet_formula = as.formula("~group")) +
  theme(legend.position = "bottom")

g_pie1

```    

[Return to Top](#top_cell_labeling)  
  
<a id="group_fct_mito_umi_bycelltype"></a> 
  
#### Fraction Mitochondrial UMI Group by Cell Types  

```{r mito_group_piechart_bycelltype, results = "asis"}
stm("Plotting fraction mitochondrial umi picharts by cell type")
ncol_plot <- 5
g_pie_cells <- qc_piechart(meta = mito_groups, 
       category_y = "group", 
       category_name = "Fraction Mitochondrial UMI", 
       stat = "count", 
       colorset_y = "varibow",
       label_size = 3, 
       plot_font_size = 12,
       nudge_x_label = 0.2,
       facet_formula = as.formula("~facet_group"), ncol = ncol_plot) +
  theme(legend.position = "bottom")

temp_fig_width <- 14
n_cell_type_levels <- nrow(cell_type_palette)
temp_fig_height <- ceiling(n_cell_type_levels/ncol_plot)*2 + 0.25

make_subchunk(g_pie_cells, subchunk_name = "mito_group_piechart_bycelltype_subchunk", quiet_knit = T, 
              chunk_opt_list = list(fig.width = temp_fig_width, fig.height = temp_fig_height, class.output = "superbigimage"))
```  

[Return to Top](#top_cell_labeling)  

<a id="marker_visualization"></a>   

#### Marker Visualization

```{r marker_umap,fig.height = 35, fig.width = 25,  class = "superbigimage"}
# this variable moved to head of code/parameters
# genes_plot <- c("CD3D","CD3E", "CD3G","CD247","CD4", "CD8A",
#             "HLA-DRA", "CD14", "FCGR3A", "IL3RA", "ITGAX",
#            "CD19", "MS4A1", "CD79A", "NCAM1", "NKG7", "PPBP", "IL7R",
#            "FUT4", "ITGAM","FCGR2B","FCER1A")


stm("Plotting UMAP of marker genes")

cDF <- normCounts

if(!all(genes_plot %in% rownames(cDF))){
  
}

# Add normalized gene counts to the analysis dataframe (UMAP + meta)
markerDF <- t(cDF[genes_plot, ]) %>% as.data.frame()
umapDF2 <- umapDF[, c("UMAP_1_merged", "UMAP_2_merged","fct_mito_umi")]
umapDF2 <- cbind(umapDF2, markerDF) %>%
  tidyr::gather(key = gene, value = value, -UMAP_1_merged, -UMAP_2_merged)
umapDF2$gene <- factor(umapDF2$gene, levels = genes_plot)

# plot UMAP per marker
marker_umap_l <- list()
for(G in genes_plot) {
  umapDF3 <- umapDF2 %>% dplyr::filter(gene %in% G)
  marker_umap_l[[G]] <- ggplot(data = umapDF3,
                               mapping = aes(x = UMAP_1_merged,
                                             y = UMAP_2_merged,
                                             color = as.numeric(value))) +
    geom_point(size = 0.8) +
    scale_color_gradient(low = "white", high = "red") +
    labs(x = "UMAP 1", y = "UMAP 2") +
    labs(color = "NormCount") +
    ggtitle(G)+
    theme(aspect.ratio = 1/1,
          panel.background = element_rect(fill = "#b6b7b2"),
          plot.title = element_text(size = 20),
          axis.text.x = element_text(size = 12, color = "black"),
          axis.text.y = element_text(size = 12, color = "black"),
          axis.line = element_line(color = "grey"),
          panel.grid = element_blank())
}



cowplot::plot_grid(plotlist = marker_umap_l, ncol = 4)

```  

[Return to Top](#top_cell_labeling)

### Bridging Control  

<a id="top_control"></a> 

Comparing batch bridging control to previous reference batches.  

#### Contents 
##### [N Cells per Cell Type](#control_cells_per_type)
##### [Cell Type Proportions](#control_celltype_proportions)
##### [Bridging Control UMAP](#scrna_control_umap)

```{r control_summary, eval=has_controls}
all_control <- all_control %>% 
  mutate(control_type = ifelse(batch_id == batch, "new", "reference")) %>%
  group_by(control_type) %>%
  mutate(control_batch = paste(sort(unique(batch_id)), collapse = ";")) %>%
  ungroup()


```  

<a id="control_cells_per_type"></a> 

#### N Cells per Cell Type

```{r control_label_counts, eval=has_controls}
all_control <- setDT(all_control)
lab_order <- sort(table(all_control[,get(cell_label_column_name)][all_control$control_type=="reference"]), decreasing = TRUE)

# all_control <- all_control %>% 
#   mutate(seurat_pbmc_type = factor(seurat_pbmc_type, levels = names(lab_order)))

all_control[,cell_label_fmt := factor(get(cell_label_column_name), levels = names(lab_order))]


ctrl_by_type <- all_control %>% 
  group_by(control_type, cell_label_fmt) %>% 
  summarize(N = n(), .groups = "drop") %>% 
  ungroup() %>% 
  group_by(control_type) %>% 
  mutate(pct = N/sum(N)*100) %>% 
  arrange(-pct) %>% 
  mutate(cell_label_fmt = factor(cell_label_fmt, levels = lab_order))

qc_aligned_barplot(meta=all_control, category_x = "cell_label_fmt", name_x = "Cell Label",
                   category_y = "batch_id", name_y = "N Cells", colorset_y = "rainbow", category_name = "Batch")

```    

[Return to Top](#top_control)   

<a id="control_celltype_proportions"></a> 

#### Cell Type Proportions

```{r control_pct_counts, fig.width = 10, class.output = "superbigimage", eval=has_controls}

qc_stacked_barplot(meta=all_control, category_x = "pool_id", name_x = "Pool ID",
                   category_y = "cell_label_fmt", name_y = "Percent Cells", 
                   colorset_y = "rainbow", category_name = "Cell Label",as_fraction = TRUE)

```  

[Return to Top](#top_control)   

<a id="scrna_control_umap"></a> 

#### Bridging Control UMAP 

<details style="color: lightgray;"> 
  <summary>Expand Code</summary> 

   
```{r umap_control, eval=has_controls}
stm("Reading and merging all control count matrices")
# Merge the count matrices for all samples into 1 table
suppressWarnings(future::plan("multiprocess", workers = avail_workers))

all_ctrl_list <- future.apply::future_lapply(all_control_h5, H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
# Confirm that features are same between control 
all_same_features <- do.call(all.equal, lapply(all_ctrl_list, row.names))
if(!all_same_features){
  stop("All batch control samples do not have the same features in count matrix")
}

all_ctrl_mat <- do.call(cbind, all_ctrl_list)
all_ctrl_cells_bc <- all_control$original_barcodes

```   

```{r seurat_normalize_ctrl, eval=has_controls}
# Create Seurat object
stm("Creating Seurat object from merged data")
ctrl_so <- Seurat::CreateSeuratObject(counts = all_ctrl_mat)

# Normalize data
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
stm("Normalizing data")
ctrl_so <- Seurat::NormalizeData(object = ctrl_so, 
                                 normalization.method = "LogNormalize",
                                 scale.factor = 10000,
                                 margin = 1)

normCountsctrl <- ctrl_so[["RNA"]]@data

```


```{r PCA_ctrl, eval=has_controls}
# Run PCA on variable features for first 50 PCs
pc_dims_ctrl <- min(ncol(ctrl_so) - 1, 50)

stm("Finding Variable Features Control")
ctrl_so <- FindVariableFeatures(object = ctrl_so)

stm("Scaling Data Control")
ctrl_so <- ScaleData(object = ctrl_so, verbose = FALSE)

stm("Running PCA Control")
ctrl_so <- RunPCA(object = ctrl_so, npcs = pc_dims_ctrl, verbose = FALSE)  

```  


```{r Jackstraw_ctrl, message = FALSE, eval=has_controls}
stm("Determining dimensionality via jackstraw method control")

labels_order_ctrl <- all_control[,get(cell_label_column_name)][match(all_control$barcodes, colnames(ctrl_so))]
# labels_order_ctrl <- all_control$seurat_pbmc_type[match(all_control$barcodes,colnames(ctrl_so))]
names(labels_order_ctrl) <- colnames(ctrl_so)

jackstraw_cells_ctrl <- sample_cells(labels_order_ctrl, 100)
jackstraw_so_ctrl <- ctrl_so[,jackstraw_cells_ctrl]

jackstraw_so_ctrl <- JackStraw(object = jackstraw_so_ctrl, 
                          dims = pc_dims, 
                          num.replicate = 50, 
                          verbose = FALSE)
jackstraw_so_ctrl <- ScoreJackStraw(object = jackstraw_so_ctrl, 
                               dims = 1:pc_dims)

pc_pvals_ctrl <- jackstraw_so_ctrl@reductions$pca@jackstraw$overall.p.values[,2]
good_pcs_ctrl <- pc_pvals_ctrl < 0.05

pc_embeddings_ctrl <- ctrl_so@reductions$pca@cell.embeddings

nPC_ctrl <- sum(good_pcs_ctrl)

pc_var_ctrl <- Seurat::Stdev(ctrl_so, reduction = "pca")^2
total_var_ctrl <- ctrl_so@reductions$pca@misc$total.variance
var_selected_pc_ctrl <- sum(pc_var_ctrl[good_pcs_ctrl])/total_var_ctrl
cumvar_string_ctrl <- sprintf(fmt = "%.1f", var_selected_pc_ctrl*100)

stm(sprintf("Selected %s significant pcs via jackstraw, %s%% explained variation", nPC_ctrl, cumvar_string_ctrl))
```  

```{r merged_umap_ctrl, eval=has_controls}
# Run UMAP
suppressWarnings(future::plan("multiprocess", workers = avail_workers))
stm("Running UMAP on selected coordinates...")
## As the number of dimensions, use the same PCs as input to the clustering analysis

ctrl_so <- Seurat::RunUMAP(ctrl_so,
                           dims = c(1:50)[good_pcs_ctrl],
                           umap.method = "uwot",
                           seed.use = 3,
                           verbose = FALSE)

```


```{r umap_cleanup_ctrl, eval=has_controls}
# Get UMAP coordinates
umapDF_ctrl <- ctrl_so[["umap"]]@cell.embeddings %>%
  as.data.frame() %>%
  dplyr::rename(UMAP_1_merged = UMAP_1, UMAP_2_merged = UMAP_2) %>%
  tibble::rownames_to_column(var = "barcodes")
umapDF_ctrl <- merge(umapDF_ctrl, all_control, by = "barcodes")
rownames(umapDF_ctrl) <- umapDF_ctrl$barcodes
umapDF_ctrl <- umapDF_ctrl[rownames(ctrl_so@"meta.data"), , drop = F]

normCountsctrl <- ctrl_so[["RNA"]]@data
if(!all(rownames(umapDF_ctrl) == colnames(normCountsctrl))){
  stop("Merged controls UMAP dataframe does not match columns in normalized counts")
}

```   
</details>  
<!-- end of details section collapsing multiple no-output code blocks to save space -->  

```{r eval=has_controls, results="asis"}
cat(sprintf("Batch Control UMAP using %s principal components (%s%% explained variance).",nPC_ctrl,cumvar_string_ctrl))
```  

```{r umap_quality_ctrl,  results = "asis", fig.height = 20, fig.width = 20, class.output = "superbigimage", eval=has_controls}
stm("Plotting Control UMAP by Data Quality Metrics")

# Gene scaling
# min_genes <- min(100, meta$n_genes)
max_genes <- max(8000,all_control$n_genes)
max_umi <- max(60000,all_control$n_umis)
point_size <- 0.4

# Cell Types
g_base <- ggplot(umapDF_ctrl %>% arrange(desc(control_type)), aes(UMAP_1_merged, UMAP_2_merged)) # the new batch will be plotted on top


stm("Plotting cell type UMAP")
g1 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = get(cell_label_column_name))) +
  ggtitle("Cell Labels")+
  scale_color_manual(values = cell_type_palette$cell_color, 
                     breaks = cell_type_palette$cell_labels,
                     name = "Cell Label") +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20), 
        legend.key.size = unit(1, 'lines'),
        legend.text = element_text(size = 14)) + 
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Labeling Scores
stm("Plotting Labeling Score UMAP")
g2 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color =  get(cell_label_score_column_name))) +
  ggtitle("Label Scores")+
  scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
                        breaks = c(0,0.25,0.5,0.75,1),
                        name = "Cell Label Score") +
  theme_bw() +
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.text = element_text(size = 14))

# Control Type
stm("Plotting Control type UMAP")
g3 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = control_batch)) +
  ggtitle("Control Batch")+
  theme_bw()+
  theme(aspect.ratio = 1/1,
        title = element_text(size = 20),
        legend.key.size = unit(1, 'lines'),
        legend.text = element_text(size = 14)) +
  guides(colour = guide_legend(override.aes = list(size = 3)))

aligned_plots <- cowplot::align_plots(g1, g2,g3, align = "hv", axis = "tblr")  # uniform plot sizing 

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   aligned_plots[[3]],
                   ncol = 2)


```  

[Return to Top](#top_control)   


### Session Information 
<a id="top_session_info"></a>  

Batch processing metadata:  

```{r echo_processing_method}
in_batch_meta 

```  

Config File:  
```{r echo_config_files}
in_config

```  

Key File:  
```{r echo_key_files}
in_key

```  

Files Analyzed:  
```{r echo_files}
all_files_bn <- basename(all_labeled_h5)
all_files_bn

all_hto_json_bn <- basename(all_hto_json)
all_hto_json_bn

all_multiplet_bn <- basename(all_multiplet_h5)  
all_multiplet_bn  

all_control_bn <- basename(all_control_h5)  
all_control_bn  

```

Session Info:  
```{r Session Info}
sessionInfo()
```

Total time elapsed
```{r Show Time}
end_time <- Sys.time()
diff_time <- end_time - start_time
time_message <- paste0("Elapsed Time: ", 
                       round(diff_time, 3),
                       " ", units(diff_time))
print(time_message)
stm(time_message)
stm("Batch report process complete.")
```  

[Return to Top](#top_session_info)

# {.tabset} 

  
scRNA seq Batch Labeling report  v.`r {scrna_batch_label_parent_version}`
