<!-- # Child Rmarkdown Document for scRNA hashing QC outputs-->
<!-- Parent document must have a variable "rna_in_dir" containing a subfolder "labeled_h5" -->


```{r}
scrna_hashing_module_version <- "1.0.1"  # 20211006--update to handle missing expected hto

```

<!-- # ```{r test, include = FALSE} -->
<!-- # rna_in_dir <- system.file("extdata/FullBatch", package = "batchreporter") -->
<!-- # in_key <- system.file("extdata/example_sample_key.csv", package = "batchreporter") -->
<!-- #  -->
<!-- # ``` -->

<a id="top_cell_hashing"></a> 

The following data summarizes parsing of HTO's per well and filtering for singlet cells based on cross-hash doublet/multiplet identification.  

#### Contents 

##### [Hash Tag UMI](#hashtag_umi)
- [Pool HTO UMI Counts](#pool_hto_umi_counts)
- [Well HTO UMI Counts](#well_hto_umi_counts)
- [Well HTO UMI Counts by HTO](#well_hto_umi_counts_hto)

##### [HTO Parsing](#hto_parsing)
- [HTO Positive Cells per Well](#hto_positive_cells_well)
- [HTO Distributions](#hto_distributions)
- [HTO Cutoffs](#hto_cutoffs)
- [HTO Positivity Rate](#hto_positivity_rate)  

##### [HTO Category Summary](#hto_category_summary)  
- [Pool Hashing Summary](#pool_hashing_summary)
- [HTO Category Counts by Well](#hto_category_well)
- [HTO Category Fraction by Well](#hto_category_fraction_well)  

##### [Singlet Summaries (well-based)](#singlet_section_well)  
- [Well-Based Singlet Summary](#well_singlet_summary)
- [HTO Barcode Counts by Well](#hto_barcode_well)
- [HTO Barcode Fraction by Well](#hto_barcode_fraction_well)
- [Read Counts by HTO Category and Well](#read_counts_well)
- [UMI Counts by HTO Category and Well](#umi_counts_well)
- [Gene Counts by HTO Category and Well](#gene_counts_well)

##### [Singlet Summaries (hto-based)](#singlet_section_hto)  
- [Hash-Based Singlet Summary](#hto_singlet_summary)
- [Well Counts per HTO Barcode Plot](#well_hto_barcode)
- [Well Fraction per HTO Barcode Plot](#well_fraction_hto_barcode)
- [Read Counts by HTO Category and Barcode](#read_counts_hto)
- [UMI Counts by HTO Category and Barcode](#umi_counts_hto)
- [Gene Counts by HTO Category and Barcode](#gene_counts_hto)
  
  
```{r scrna_hash_dependency_check, include = FALSE}
# check main rna input directory
assertthat::assert_that(exists("rna_in_dir"), 
                        msg = "Attempting to run scRNA hashing module. Missing `rna_in_dir` variable definition")
# check hash folder exists
assertthat::assert_that(length(dir(file.path(rna_in_dir,"hash"))) > 0, 
                        msg = "Attempting to run scRNA hashing module. Input `rna_in_dir` does not contain hash folder")
# check multiplet h5 exists
assertthat::assert_that(length(dir(file.path(rna_in_dir,"multiplet_h5"))) > 0, 
                        msg = "Attempting to run scRNA hashing module. Input `rna_in_dir` does not contain multiplet_h5 folder")

# check that we have h5 files provided. Can accept any merged h5 and labeled h5
h5_file_dir_options <- file.path(rna_in_dir, c("merged_h5","labeled_h5"))
h5_file_dir <- h5_file_dir_options[dir.exists(h5_file_dir_options)][1]
h5_file_dir_options <- file.path(rna_in_dir, c("merged_h5","labeled_h5"))
assertthat::assert_that(any(dir.exists(h5_file_dir_options)))

h5_file_type <- ifelse(h5_file_dir == h5_file_dir_options[1],"merged" ,
                       ifelse( h5_file_dir == h5_file_dir_options[2],"labeled", 
                               stop("scrna seq module requires an h5 input folder in input directory")))

assertthat::assert_that(exists("in_key"))
assertthat::assert_that(exists("sample_column_name"))

```  

<!-- create details section to collapse multiple no-output code blocks to save space -->
<details style="color: lightgray;">  
  <summary>Expand Code</summary> 
```{r rna_hash_files}
## hto_key <- system.file(file.path("reference",hash_key), package = "HTOparser")  # Parameterize this value

in_hto_key <- fread(hto_key, header = FALSE, col.names = c("hto_barcode","hto_name")) %>% 
  mutate(hto_order = as.numeric(gsub("HT","", hto_name))) %>% 
  mutate(hto_name = factor(hto_name, levels = hto_name[order(hto_order)])) %>% # use HT number value to reorder the HT levels
  select(-hto_order)

if(!exists("all_hto_json")){
  all_hto_json <- list.files(path = file.path(rna_in_dir,"hash"), pattern = "hto_processing_metrics.json$", full.names = TRUE, recursive = TRUE)
  stm(paste0("IN JSON Files        :\n\t", paste(all_hto_json, collapse = "\n\t")))
}

if(!exists("all_multiplet_h5")){
  all_multiplet_h5 <- list.files(path = file.path(rna_in_dir,"multiplet_h5"), pattern = "_multiplet.h5$", full.names = TRUE, recursive = TRUE)
  stm(paste0("IN Multiplet H5 Files:\n\t", paste(all_multiplet_h5, collapse = "\n\t")))
}

expected_files <- switch(h5_file_type,
                         cellranger = "all_cellranger_h5",
                         merged = "all_merged_h5",
                         labeled = "all_labeled_h5")

if(exists(expected_files)){
  all_h5 <- get(expected_files)
} else {
  all_h5 <- list.files(path = h5_file_dir, 
                               pattern = ".h5$", 
                               full.names = TRUE, recursive = TRUE)
}
stm(paste0("IN Labeled H5 Files for scRNA hashing module:\n\t", paste(all_h5, collapse = "\n\t")))

if(!exists("df_key")){
  df_key <- data.table::fread(in_key)
}

```

```{r scrna_hash_meta_setup, fig.width = 6, fig.height = 30}
meta[in_hto_key, on = 'hto_barcode', hto_name := i.hto_name]  # merge in the hto names
# meta[ , plot_barcode:= sprintf("%s\n%s", hto_barcode, sample_pool)]
meta[ , sample_hto:= sprintf("%s\n%s", hto_name, get(sample_column_name))]
meta[ , sample_hto_pool:= sprintf("%s\n%s%s", hto_name, get(sample_column_name),pool_id)]
meta[ , hto_order:=  as.numeric(gsub("HT","", hto_name))]
meta[ , sample_hto_pool:=  factor(sample_hto_pool, levels = unique(sample_hto_pool[order(pool_id, hto_order)]))]
meta[ , hto_order:= NULL]

all_meta[ , hto_category := factor(hto_category, levels = c("no_hash", "singlet", "doublet", "multiplet"))]
```  


```{r scrna_hash_read_json}
# Read in json files
if(!exists("well_hto_json_df")){
  stm("Reading in hto processing metrics json files")
  well_hto_json_list <- future_lapply(all_hto_json, read_hto_well_json)
  well_hto_json_df <- do.call(rbind, well_hto_json_list)
  well_hto_json_df <- well_hto_json_df %>% 
    left_join(in_hto_key, by = "hto_barcode") %>% 
    dplyr::mutate(pool_id_short = gsub(".*-", "", gsub("C.*","", well_id))) %>% 
    dplyr::mutate(pool_id = gsub("C.*","", well_id)) %>% 
    dplyr::mutate(sample_hto = paste(hto_name, get(sample_column_name), sep = "\n")) %>% 
    dplyr::mutate(sample_hto = factor(sample_hto, levels = unique(sample_hto[order(hto_name, pool_id)]))) %>% 
    dplyr::mutate(hto_name_barcode = paste(hto_name, hto_barcode, sep = "\n")) %>%  
    dplyr::mutate(hto_name_barcode = factor(hto_name_barcode, levels = unique(hto_name_barcode[order(hto_name)]))) %>%
    dplyr::mutate(sample_pool = paste(get(sample_column_name), pool_id_short, sep = "_")) %>% 
    dplyr::mutate(sample_pool_hto = paste(sample_pool, hto_barcode, sep = "\n")) 
  
  remove("well_hto_json_list")
}
```  

```{r scrna_hash_read_hash}
if(!exists("multiplet_hash")) {
  stm("Reading in hash matrixes from labeled h5 and multiplet h5 files")
  labeled_hash_list <- future_lapply(all_h5, H5weaver::read_h5_dgCMatrix, target = "hash", feature_names = "id", sample_names = "barcodes", index1 = TRUE)
  labeled_hash <- do.call(cbind, labeled_hash_list)
  
  multiplet_hash_list <- future_lapply(all_multiplet_h5, read_h5_dgCMatrix, target = "hash", feature_names = "id", sample_names = "barcodes", index1 = TRUE)
  multiplet_hash <- do.call(cbind, multiplet_hash_list)
  
  all_hash <- cbind(labeled_hash, multiplet_hash)
  
  remove("labeled_hash_list","multiplet_hash_list","labeled_hash","multiplet_hash")
}
```  

```{r scrna_hash_hto_setup, fig.width = 6, fig.height = 30}
stm("Formatting hto cutoff data")

# Create data table w/ 1 row per cell per hto, add hto counts
all_hash_fmt <- as.data.frame(t(all_hash))
setDT(all_hash_fmt, keep.rownames = "barcodes")
all_hash_fmt <- melt(all_hash_fmt, id.vars ="barcodes", variable.name ="hto", 
                       value.name= "count")
# Merge in metadata
all_hash_fmt <- all_hash_fmt[all_meta[,.(barcodes, well_id, pool_id, hto_barcode, hto_category)], on ="barcodes"]
# Merge in well/hto level hashing info
all_hash_fmt <- all_hash_fmt[well_hto_json_df, on = c(hto="hto_barcode", well_id="well_id", pool_id = "pool_id")]
# Add variables for plotting hto distributions
all_hash_fmt[, log_count := ifelse(count>0, log10(count), NA)] 
all_hash_fmt[, log_cutoff := ifelse(is.na(log_count), NA, log10(cutoff))] 
all_hash_fmt[, log_count_bin := cut(log_count, 
                                      breaks = seq(min(log_count,na.rm=T), 
                                                   max(log_count,na.rm=T), 
                                                   length.out = 30))] 

# Format labels as "hash not detected" for any well/hash that has no cells with hash count >5
low_hto_cutoff <- 5
all_hash_fmt[, n_count := sum(count > low_hto_cutoff), by = .(well_id, hto)]
all_hash_fmt[, detected := n_count > 0] 
all_hash_fmt[, plot_label := ifelse(detected, "", "Hash not detected")] 

all_hash_fmt[, log_count := ifelse(detected, log_count, NA)]   # censor counts for plotting if overall hash not detected
all_hash_fmt[, log_cutoff := ifelse(detected, log_cutoff, NA)]  # censor cutoffs for plotting if overall hash not detected 

pools <- unique(all_hash_fmt$pool_id)
```  

</details>  
<!-- end of details section collapsing multiple no-output code blocks to save space -->

<a id="hashtag_umi"></a>

#### Hash Tag UMI  

<a id="pool_hto_umi_counts"></a>

#####  Pool HTO UMI Counts
```{r umi_per_pool}
stm("Output total hto umi per pool")
pool_info <- all_hash_fmt %>%
  dplyr::group_by(pool_id) %>%
  dplyr::summarize(total_hto_umi = formatC(sum(count), big.mark = ",", digits = 0, format = "f"), .groups = "drop")
  
pool_info %>%
  gt::gt() %>%
  gt::cols_align(align = "right", columns = 2)

```  

<a id="well_hto_umi_counts"></a>

#####  Well HTO UMI Counts
```{r all_hto_counts, results="asis"}
stm("Output barplot total hto umi per pool")
hash_by_well <- all_hash_fmt[,.(hto_count=sum(count)), 
                             by = .(pool_id, well_id, hto, sample_pool_hto, hto_name_barcode)]

g <- ggplot(hash_by_well, aes(well_id, hto_count)) +
  geom_bar(stat="identity", fill = "blue") +
  theme_bw() +
  scale_y_continuous(labels = scales::comma) +
  guides(fill=guide_legend(title="HTO")) +
  theme(axis.text.x = element_text(angle = 90, vjust=0.5)) +
  xlab("Wells") +
  ylab("Total HTO UMI") +
  facet_wrap(~pool_id, ncol = n_pools, scales = "free_x", drop = TRUE)

tempwidth <- max(n_samples*0.5 + n_pools*0.1 + 0.2, 4)


make_subchunk(g, subchunk_name = "hto_totalumi_subchunk",quiet_knit = T,
              chunk_opt_list = list(fig.width = tempwidth, fig.height = 3))

```  

[Return to Top](#top_cell_hashing) 

<a id="well_hto_umi_counts_hto"></a>

#####  Well HTO UMI Counts by HTO  
```{r all_hto_counts_by_hto, , results="asis"}
stm("Output barplot total hto umi per pool per hto")
g2 <- qc_aligned_barplot_facet(hash_by_well, 
                               category_x = "well_id", 
                               name_x = "Wells", 
                               category_y = "hto_name_barcode", 
                               category_name = "hto", 
                               stat = "identity", 
                               variable_y_identity = "hto_count", 
                               name_y = "HTO UMI Counts", 
                               facet_formula = formula("~pool_id"), 
                               scales = "free_x", 
                               drop = TRUE)

tempwidth2 <- n_samples*0.5 + n_pools*0.1 + 2.2

make_subchunk(g2, subchunk_name = "hto_umibyhto_subchunk",quiet_knit = T,
              chunk_opt_list = list(fig.width = tempwidth, fig.height = 6))

```  

[Return to Top](#top_cell_hashing) 

<a id="hto_parsing"></a>

#### HTO Parsing
Showing number of cells positively associated with each hash tag for each well. Includes singlets and multiplets.  

<a id="hto_positive_cells_well"></a>

##### HTO Positive Cells per Well   
```{r hto_positive_matrix, results="asis"}
stm("Calculations for heatmap positive hto per well")
# Expected HTO per well based on input sample sheet
all_wells <- trimws(unique(unlist(strsplit(df_key$WellID, split = ";"))))
all_hto <- in_hto_key$hto_name
df_expected_hto <- expand.grid(well_id = all_wells, hto_name = all_hto) %>% 
  left_join(in_hto_key, by = "hto_name")
df_expected_hto$hto_expected <- mapply(function(x, y){any(grepl(x, df_key$WellID[df_key$HashTag == y]))},
                                   df_expected_hto$well_id, 
                                   df_expected_hto$hto_name)  


# N Cells Raw HTO UMI per well, defined as cells above cutoff

df_expected_hto$n_positive_cells <- mapply(function(x, y){
      well_hto_json_df$n_pos[which(well_hto_json_df$well_id == x & well_hto_json_df$hto_name == y)]
    },
    df_expected_hto$well_id, 
    df_expected_hto$hto_name)
df_expected_hto$n_positive_cells[df_expected_hto$n_positive_cells <= 5] <- NA  # change to NA to color undetected tiles uniquely


# N Cells Pos HTO per well, defined as cells above cutoff
df_expected_hto$n_positive_cells <- mapply(function(x, y){
      well_hto_json_df$n_pos[which(well_hto_json_df$well_id == x & well_hto_json_df$hto_name == y)]
    },
    df_expected_hto$well_id, 
    df_expected_hto$hto_name)
df_expected_hto$n_positive_cells[df_expected_hto$n_positive_cells <= 5] <- NA  # change to NA to color undetected tiles uniquely

# Flag for cells not detected
df_expected_hto$hto_detection_status <-  mapply(function(x, y){
      ifelse(x == TRUE & is.na(y),"Missing",
             ifelse(x == TRUE & !is.na(y), "Detected",
             ifelse(x == FALSE & is.na(y), "Not Used", NA)))
    },
    df_expected_hto$hto_expected, 
    df_expected_hto$n_positive_cells)

# Heat Map 
# temp_scale <- scales::rescale(c(0, 5, 1, max(df_expected_hto$n_positive_cells)))
stm("Output heatmap positive hto per well")
hm_pos <- ggplot(df_expected_hto, aes(hto_name, y=factor(well_id, levels = sort(unique(well_id), decreasing = TRUE)))) +
  geom_tile(aes(fill = n_positive_cells, color = factor(hto_detection_status, levels = c("Not Used", "Detected","Missing"))), 
            width = 0.7, height = 0.7, size = 1) +
  scale_fill_viridis_c(option = "D", na.value = "grey") +
  scale_color_manual(name = "hto_detection_status", breaks = c("Not Used", "Detected","Missing"), values = c("grey","black","red"), drop = FALSE) +
  scale_x_discrete(position = "top") +
  xlab("HTO") +
  ylab("Well") +
  facet_grid(substr(well_id,1,7) ~., drop = T, scales = "free_y")

if(!exists("n_wells")){
  wells <- unlist(strsplit(unique(df_key$WellID), split = ";"))
  n_wells <- length(wells)
}

temp_figheight <- n_wells*0.25 + 1
temp_figwidth <- length(unique(df_expected_hto$hto_name))*0.4 + 2

make_subchunk(hm_pos, subchunk_name="hto_positive_matrix_subchunk", quiet_knit = T, 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth))

```   

[Return to Top](#top_cell_hashing) 
  
<a id="hto_distributions"></a>

##### HTO Distributions


A specific hashtag oligo (HTO) is detected in a well when >5 cells have any raw counts. Calculated cutoffs separate cells with
background HTO count levels from cells considered positive for the HTO.  

```{r hto_ridge_hist, class.output = "superbigimage", results = "asis"}
stm("Plotting hto count ridgeplots")

get_plt_ht_temp <- function(n_well_pool, n_hto, title_label_height = 0.5, row_height_constant = 3){
    plot_height <- (n_well_pool*0.4 + row_height_constant)*ceiling(n_hto/7) + title_label_height
    return(plot_height)
}

# Censor hto if detected in <= 5 cells in the well
for (i in seq_along(pools)){
  # pool data
  df <- all_hash_fmt %>% 
    dplyr::filter(pool_id == pools[i]) %>% 
    dplyr::mutate(well_id = factor(well_id, levels = sort(unique(well_id), decreasing=T))) 
  
  # cutoff line segment
  df_lines <- df %>%
    dplyr::select(well_id, sample_hto, hto, cutoff, log_cutoff)  %>% 
    dplyr::filter(!is.na(log_cutoff)) %>% 
    dplyr::distinct() 
  
  # labels for hash not detected
  detected_labels <- df %>% 
    dplyr::select(well_id, hto, sample_hto, plot_label) %>% 
  dplyr::distinct()
  
  x_max <- max(all_hash_fmt$log_count, na.rm = T)
  x_min <- -0.1
  x_label <- (x_max - x_min)/2 + x_min

  # Plot
  g_ridge <- ggplot(df, aes(x = log_count, y = well_id)) +
    ggridges::geom_density_ridges(
                                  scale = 7, 
                                  stat = "binline",
                                  binwidth = 0.1,
                                  size = 0.5, # line width
                                  aes(color = well_id), alpha = 0,
                                  na.rm = TRUE) +
    geom_segment(data = df_lines, aes(x = log_cutoff, xend = log_cutoff,
                                      y = as.numeric(well_id), yend = as.numeric(well_id) + 0.9,
                                      linetype = "well cutoff"), 
                 color = "black", na.rm = TRUE) +
    scale_x_continuous(limits = c(x_min, x_max)) +
    scale_y_discrete(expand = c(0.01, 0)) +
    scale_linetype_manual("cutoff",values=c("well cutoff"=1)) +
    geom_text(data = detected_labels, x= x_label, 
              aes(y= as.numeric(well_id),label = plot_label), 
              size = 4, vjust = 0) +
    facet_wrap(~sample_hto, ncol = 7) +
    ggtitle(pools[i]) +
    xlab("log10(Count)") +
    ylab("Well ID") +
    theme_bw() +
    theme(axis.text.y = element_text(size = 12),
          axis.title = element_text(size = 18),
          plot.title = element_text(size = 24),
          strip.text = element_text(size = 12),
          legend.text = element_text(size = 12))
  
  # Set Height
  temp_height <- get_plt_ht_temp(n_well_pool = length(unique(df$well_id)), n_hto = length(unique(df$hto)))
  
  # Output plot with custom chunk format
  batchreporter::make_subchunk(g_ridge, subchunk_name = paste0("ridge_", i), 
                chunk_opt_list = list(fig.height = temp_height, fig.width = 18, warning = FALSE), 
                quiet_knit = TRUE)
}

```   

[Return to Top](#top_cell_hashing) 

<a id="hto_cutoffs"></a>

##### HTO Cutoffs  

```{r hto_assignment, results = "asis"}
stm("Plotting hto cutoff boxplots")
g_cutoff_box <- ggplot(well_hto_json_df, aes(sample_hto, cutoff, color = hto_barcode)) +
  suppressWarnings(geom_point(alpha = 0.4, position = position_jitter(height = 0, width = 0.3, seed = 20201112),
             aes(text = sprintf("Well ID: %s",  well_id)))) +
  geom_boxplot(alpha = 0, outlier.alpha = 1, color = "black") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90)) +
  facet_wrap(~pool_id, drop = TRUE, scales = "free_x", ncol = 2)+
  ggtitle("Well-Specific HTO Cutoffs") 

temp_figwidth <- (4*((n_pools>1)+1) + 3)
temp_figheight <- ceiling(n_pools/2)*5 + 0.4

ply_cutoff_box <- plotly::ggplotly(g_cutoff_box) %>% 
  adjust_axis_title_spacing_plotly("x", adjustment = -1.3/temp_figheight) %>%
  adjust_axis_title_spacing_plotly("y", adjustment = -0.5/temp_figwidth) %>% 
  plotly::layout(xaxis = list(title = list(text = "", standoff = 30L)),
                 yaxis = list(title = list(text = "", standoff = 20L))) 

make_subchunk(ply_cutoff_box, subchunk_name = "hto_assignment_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)

```  
  
[Return to  Top](#top_cell_hashing)  

<a id="hto_positivity_rate"></a>

##### HTO Positivity Rate
  
```{r hto_pos_cutoff, results = "asis"}
stm("Plotting hto positive call box plots")
g_cutoff_pos <- ggplot(well_hto_json_df, aes(sample_hto, frac_pos, color = hto_barcode)) +
  suppressWarnings(geom_point(alpha = 0.4, position = position_jitter(height = 0, seed = 20201112),
             aes(text = sprintf("Well ID: %s",  well_id)))) +
  geom_boxplot(alpha = 0, outlier.alpha = 1, color = "black") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
                axis.title.x = element_text(margin = margin(c(15,0,1,0)))) +
  facet_wrap(~pool_id, drop = TRUE, scales = "free_x", ncol = 2)+
  ggtitle("Fraction Positive HTO Calls per Well")

temp_figwidth <- (4*((n_pools>1)+1) + 3)
temp_figheight <- ceiling(n_pools/2)*5 + 0.4

ply_cutoff_pos <- plotly::ggplotly(g_cutoff_pos) %>% 
  adjust_axis_title_spacing_plotly("x", adjustment = -1.3/temp_figheight) %>%
  adjust_axis_title_spacing_plotly("y", adjustment = -0.5/temp_figwidth) %>% 
  plotly::layout(xaxis = list(title = list(text = "", standoff = 30L)),
                 yaxis = list(title = list(text = "", standoff = 20L))) 

make_subchunk(ply_cutoff_pos, subchunk_name = "hto_positive_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)
```  
  
[Return to Top](#top_cell_hashing)  
    
<a id="hto_category_summary"></a>

#### HTO Category Summary

<a id="pool_hashing_summary"></a>

##### Pool Hashing Summary
```{r scrna_hash_pool_summary}
stm("Output pool based summary table")
pool_summary <- all_meta[ ,.(n_cells = .N,
                             median_reads = median(n_reads),
                             median_umis = median(n_umis),
                             median_genes = median(n_genes)), 
                          by = .(pool_id, hto_category)]
setorder(pool_summary, pool_id, hto_category)
pool_summary[, pct_cells := round(n_cells/sum(n_cells)*100,1), by = pool_id]
setcolorder(pool_summary, c("pool_id", "hto_category", "n_cells", "pct_cells", 
                            "median_reads", "median_umis", "median_genes"))

qc_table(pool_summary)

```   
[Return to Top](#top_cell_hashing) 

<a id="hto_category_well"></a>

##### HTO Category Counts by Well   

```{r hto_cat_counts, class.output = "superbigimage",results = "asis"}
stm("Plotting hto category counts per well")

g <- qc_aligned_barplot_facet(all_meta,
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "hto_category",
                   category_name = "HTO Category",
                   colorset_y = "varibow",
                   name_y = "N Cells",
                   padding = 0.2, 
                   facet_formula = formula("~pool_id"), nrow = 1, scales = "free_x")

temp_figwidth <-  max(0.3*n_wells + 0.5*n_pools + 1.5, 4)
temp_figheight <- ceiling(n_pools/2)*4 + 0.4
make_subchunk(g, subchunk_name = "hto_cat_counts_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)
  
```  
  
[Return to Top](#top_cell_hashing)  
  
<a id="hto_category_fraction_well"></a>
    
#### HTO Category Fraction by Well  

```{r hto_cat_fractions, class.output = "superbigimage", results="asis"}
stm("Plotting hto category fraction per well")

g <- qc_stacked_barplot_facet(all_meta,
                       category_x = "well_id",
                       name_x = "Well ID",
                       category_y = "hto_category",
                       category_name = "HTO Category",
                       colorset_y = "varibow",
                       name_y = "Fraction of Cells",
                       as_fraction = TRUE, facet_formula = formula("~pool_id"), ncol=2, scales = "free_x") 

temp_figwidth <- max(0.3*n_wells + 0.5*n_pools + 1.5, 4)
temp_figheight <- ceiling(n_pools/2)*4 + 0.4
make_subchunk(g, subchunk_name = "hto_cat_fraction_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)
  
```

[Return to Top](#top_cell_hashing)  

<a id="singlet_section_well"></a>

#### Singlet Summaries (well-based)  

<a id="well_singlet_summary"></a>

##### Well-Based Summary  

<details>  
  <summary>Expand data table of summary stats by well </summary>  
  
```{r scrna_hash_well_summary}
well_summary <- all_meta[ ,.(n_cells = .N,
                             median_reads = median(n_reads),
                             median_umis = median(n_umis),
                             median_genes = median(n_genes)), 
                          by = .(pool_id, well_id, hto_category)]
setorder(well_summary, pool_id, well_id, hto_category)

qc_table(well_summary)

```   

[Return to Top](#top_cell_hashing) 

</details> 

<a id="hto_barcode_well"></a>

##### HTO Barcode Count per Well Plot  

```{r hto_counts_well, class.output = "superbigimage", results="asis"}
stm("Plotting barcode count per well and hto")

g <- qc_aligned_barplot_facet(meta = meta,
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "sample_hto_pool",
                   category_name = "HTO/Sample",
                   colorset_y = "varibow",
                   name_y = "Number of Cells",
                   padding = 0.2,
                   facet_formula = formula("~pool_id"), nrow = 1, scales = "free", drop = TRUE) 

# g <- cowplot::plot_grid(plotlist = plot_list, ncol = 2)

temp_figwidth <- max(0.3*n_wells + 0.5*n_pools + 2, 4)
temp_figheight <- ceiling(n_pools/2)*4 + 0.4
batchreporter::make_subchunk(g, subchunk_name = "hto_cat_count_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)

```   
  
[Return to Top](#top_cell_hashing)  

<a id="hto_barcode_fraction_well"></a>
  
##### HTO Barcode Fraction per Well Plot  

```{r hto_fraction_well, class.output = "superbigimage", results="asis"}
stm("Plotting barcode fraction per well and hto")

g <- qc_stacked_barplot_facet(meta = meta,
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "sample_hto_pool",
                   category_name = "HTO/Sample",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   as_fraction = TRUE, 
                   facet_formula = formula("~pool_id"), nrow = 1, scales = "free_x") +
    theme(text = element_text(size = 12))

temp_figwidth <- max(0.3*n_wells + 0.5*n_pools + 1.5, 4)
temp_figheight <- ceiling(n_pools/2)*4 + 0.4
batchreporter::make_subchunk(g, subchunk_name = "hto_fraction_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)
  
```  
  
[Return to Top](#top_cell_hashing)  

<a id="read_counts_well"></a>  

```{r}
dummy_plot <- function(msg, plottitle="", size = 8){
  ggplot(data.frame(1:2,1:2)) + 
        geom_text(x= 0.5,y =0.5,label=msg) +
        ggtitle(plottitle) +
       theme(text = element_text(size = size))

}
```
  
##### Read Counts by HTO Category and Well  


```{r read_counts_well, results="asis"}
# Reads per hto cat
stm("Generating read count violin plots")
category_reads_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_reads",
                                         name_y = "N Reads per Cell",
                                         fill = "dodgerblue")

# Reads per hto plot
g_read <- qc_violin_plot(meta,
                        category_x = "well_id",
                        name_x = "Well",
                        column_y = "n_reads",
                        name_y = "N Reads per Cell, Singlets",
                        log_y = TRUE,
                        fill = "dodgerblue") +
  ggtitle("Reads per Well")
# g_read

reads_violin_list <- list(category_reads_violins, 
                          g_read)
g_grid <-  plot_grid(plotlist = reads_violin_list,
          ncol = 2, rel_widths = c(1, 1+n_samples/4),
          nrow = 1, align = "h")
temp_figwidth = 3 + n_wells*0.4
temp_figheight = 4

batchreporter::make_subchunk(g_grid, subchunk_name = "well_read_violin_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, 
                                    warning = FALSE), 
              quiet_knit = TRUE)

``` 

<details>  
  <summary>Expand plots of reads/cell distributions per per well by hto </summary>  
  
```{r Read Count By HTO and Well Violin Plot, class.output = "superbigimage", results="asis"}
stm("Plotting read count violin plots per hto and well")  

all_sample_hto_pool <- unique(sprintf("%s\n%s%s",df_key$HashTag,df_key$SampleID,  df_key$PoolID))

plot_list <- list()
for(i in seq_along(all_sample_hto_pool)){
    temp_meta <- filter(meta, sample_hto_pool == all_sample_hto_pool[i])
    if(nrow(temp_meta) > 0){
          g <- qc_violin_plot(temp_meta,
                        category_x = "well_id",
                        name_x = "Well",
                        column_y = "n_reads",
                        name_y = "N Reads per Cell",
                        fill = "dodgerblue") +
      theme(text = element_text(size =8)) +
      ggtitle(all_sample_hto_pool[i])
    } else {
      g <- dummy_plot(msg = "No singlet cells", 
                      plottitle = all_sample_hto_pool[i], 
                      size =8 )
    }

    plot_list[[i]] <- g
}

g_grid <- cowplot::plot_grid(plotlist = plot_list, align = "tblr", ncol = 6)

temp_figwidth <- 15
temp_figheight <- ceiling(n_samples/6)*4 + 0.4
batchreporter::make_subchunk(g_grid, subchunk_name = "reads_well_hto_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)

```
</details>  

[Return to Top](#top_cell_hashing) 

<a id="umi_counts_well"></a>
  
##### UMI Counts by HTO Category and Well  

```{r umi_counts_well, results="asis"}
# Reads per hto cat
stm("Generating umi count violin plots by well")
category_umis_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_umis",
                                         name_y = "N UMIs per Cell",
                                         fill = "purple")

# Reads per hto plot
g_umi <- qc_violin_plot(meta,
                        category_x = "well_id",
                        name_x = "Well",
                        column_y = "n_umis",
                        name_y = "N UMIs per Cell, Singlets",
                        log_y = TRUE,
                        fill = "purple") +
  ggtitle("UMIs per Well")

umis_violin_list <- list(category_umis_violins, 
                          g_umi)
g_grid <-  plot_grid(plotlist = umis_violin_list,
          ncol = 2, rel_widths = c(1, 1+n_samples/4),
          nrow = 1, align = "h")
temp_figwidth = 3 + n_wells*0.4
temp_figheight = 4

batchreporter::make_subchunk(g_grid, subchunk_name = "well_umi_violin_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, 
                                    warning = FALSE), 
              quiet_knit = TRUE)

```  

<details>  
  <summary>Expand plots of UMIs/cell distributions per per well by hto </summary>  
  
```{r UMI Count By HTO and Well Violin Plot, class.output = "superbigimage", results="asis"}
stm("Plotting umi count violin plots per hto and well")  

all_sample_hto_pool <- unique(sprintf("%s\n%s%s",df_key$HashTag,df_key$SampleID,  df_key$PoolID))

plot_list <- list()
for(i in seq_along(all_sample_hto_pool)){
    
    temp_meta <- filter(meta, sample_hto_pool == all_sample_hto_pool[i])
     if(nrow(temp_meta) > 0) {
    g <- qc_violin_plot(temp_meta,
                        category_x = "well_id",
                        name_x = "Well",
                        column_y = "n_umis",
                        name_y = "N UMIs per Cell",
                        fill = "purple") +
      theme(text = element_text(size =8)) +
      ggtitle(all_sample_hto_pool[i])
    } else {
      g <- dummy_plot(msg = "No singlet cells", 
                      plottitle = all_sample_hto_pool[i], 
                      size = 8)
    }
    plot_list[[i]] <- g
}

g_grid <- cowplot::plot_grid(plotlist = plot_list, align = "tblr", ncol = 6)

temp_figwidth <- 15
temp_figheight <- ceiling(n_samples/6)*4 + 0.4
batchreporter::make_subchunk(g_grid, subchunk_name = "umis_well_hto_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)
```
</details>    

[Return to Top](#top_cell_hashing) 



<a id="gene_counts_well"></a>

##### Gene Counts by HTO Category and Well  

```{r gene_counts_well, results="asis"}
# Reads per hto cat
stm("Generating gene count violin plots by well")
category_genes_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_genes",
                                         name_y = "N Genes per Cell",
                                         fill = "orangered")
# Reads per hto plot
g_genes <- qc_violin_plot(meta,
                        category_x = "well_id",
                        name_x = "Well",
                        column_y = "n_genes",
                        name_y = "N Genes per Cell, Singlets",
                        log_y = TRUE,
                        fill = "orangered") +
  ggtitle("Genes per Well")

genes_violin_list <- list(category_genes_violins, 
                          g_genes)
g_grid <-  plot_grid(plotlist = genes_violin_list,
          ncol = 2, rel_widths = c(1, 1+n_samples/4),
          nrow = 1, align = "h")
temp_figwidth = 3 + n_wells*0.4
temp_figheight = 4

batchreporter::make_subchunk(g_grid, subchunk_name = "well_gene_violin_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, 
                                    warning = FALSE), 
              quiet_knit = TRUE)

```  

<details>  
  <summary>Expand plots of genes/cell distributions per per well by hto </summary>  
  
```{r Gene Count By HTO and Well Violin Plot, class.output = "superbigimage", results="asis"}
stm("Plotting gene count violin plots per hto and well")  

all_sample_hto_pool <- unique(sprintf("%s\n%s%s",df_key$HashTag,df_key$SampleID,  df_key$PoolID))

plot_list <- list()
for(i in seq_along(all_sample_hto_pool)){
    
    temp_meta <- filter(meta, sample_hto_pool == all_sample_hto_pool[i])
    if(nrow(temp_meta) > 0) {
    g <- qc_violin_plot(temp_meta,
                        category_x = "well_id",
                        name_x = "Well",
                        column_y = "n_genes",
                        name_y = "N Genes per Cell",
                        fill = "orangered") +
      theme(text = element_text(size = 8)) +
      ggtitle(all_sample_hto_pool[i])
    } else {
      g <- dummy_plot(msg = "No singlet cells", 
                plottitle = all_sample_hto_pool[i], 
                size = 8)
    }
    plot_list[[i]] <- g
}

g_grid <- cowplot::plot_grid(plotlist = plot_list, align = "tblr", ncol = 6)

temp_figwidth <- 15
temp_figheight <- ceiling(n_samples/6)*4 + 0.4
batchreporter::make_subchunk(g_grid, subchunk_name = "genes_well_hto_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)
```  
</details>  
  
[Return to Top](#top_cell_hashing) 


<a id="singlet_section_hto"></a>

#### Singlet Summaries (hash-based)  

<a id="hto_singlet_summary"></a>

##### Hash-Based Summary  

<details>  
  <summary>Expand data table of summary stats by hash tag </summary>  
  
```{r hash_singlet_summary}
stm("Output pool based summary table")
hto_singlet_summary <- meta[ ,.(n_singlet_cells = .N,
                             median_reads = median(n_reads),
                             median_umis = median(n_umis),
                             median_genes = median(n_genes)), 
                             by = setNames(list(pool_id, hto_name, hto_barcode, get(sample_column_name)), c('pool_id', 'hto_name','hto_barcode', sample_column_name))]
                          # by = .(pool_id, hto_name, hto_barcode, get(sample_column_name))]
setorder(hto_singlet_summary, pool_id, hto_name)
setcolorder(hto_singlet_summary, c("pool_id",sample_column_name, "hto_name", "hto_barcode", "n_singlet_cells", 
                            "median_reads", "median_umis", "median_genes"))

qc_table(hto_singlet_summary)

```  
  
[Return to Top](#top_cell_hashing)  

</details>  

<a id="well_hto_barcode"></a> 

##### Well Count per HTO Barcode Plot  

```{r Well Count By HTO Barcode Plot, class.output = "superbigimage", results="asis"}
stm("Plotting well count per hto")

plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_aligned_barplot_facet(meta = meta[pool_id == pools[i],],
                   category_x = "sample_hto_pool",
                   category_y = "well_id",
                   category_name = "Well ID",
                   name_x = "HTO/Sample",
                   colorset_y = "varibow",
                   name_y = "Number of Cells",
                   facet_formula = formula("~pool_id"), nrow = 1, scales ="free_x", drop = TRUE) 
}

g <- cowplot::plot_grid(plotlist = plot_list, ncol = 2)
temp_figwidth <- max(0.6*n_wells + 1*n_pools + 3, 8)
temp_figheight <- ceiling(n_pools/2)*4 + 0.4
batchreporter::make_subchunk(g, subchunk_name = "well_count_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE, class.output = "superbigimage"), 
              quiet_knit = TRUE)

```  
  
[Return to Top](#top_cell_hashing)  
  
<a id="well_fraction_hto_barcode"></a> 

##### Well Fraction per HTO Barcode Plot  
```{r Well Fraction By HTO Barcode Plot, class.output = "superbigimage", results="asis"}
stm("Plotting well fraction per hto")

# plot_list <- list()
# for (i in seq_along(pools)){
#   plot_list[[i]] <- qc_stacked_barplot_facet(meta = meta[pool_id == pools[i],],
#                    category_x = "sample_hto_pool",
#                    category_y = "well_id",
#                    category_name = "Well ID",
#                    name_x = "HTO/Sample",
#                    colorset_y = "varibow",
#                    name_y = "Fraction of Cells",
#                    as_fraction = TRUE , 
#                    facet_formula = formula("~pool_id"), nrow = 1, scales ="free_x", drop = TRUE) +
#   ggtitle("Well Fraction per HTO Barcode")
# }
# g <- cowplot::plot_grid(plotlist = plot_list, ncol = 2)

g <- qc_stacked_barplot_facet(meta = meta,
                   category_x = "sample_hto_pool",
                   category_y = "well_id",
                   category_name = "Well ID",
                   name_x = "HTO/Sample",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   as_fraction = TRUE , 
                   facet_formula = formula("~pool_id"), nrow = 1, scales ="free_x", drop = TRUE)

temp_figwidth <- max(0.3*n_wells + 0.5*n_pools + 1.5, 4)
temp_figheight <- ceiling(n_pools/2)*4 + 0.4
batchreporter::make_subchunk(g, subchunk_name = "well_fraction_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, warning = FALSE), 
              quiet_knit = TRUE)

```  
  
[Return to Top](#top_cell_hashing)  

<a id="read_counts_hto"></a> 

##### Read Counts by HTO Category and Barcode  
```{r read_counts, results = "asis"}
# Reads per hto cat
stm("Generating read count violin plots")
category_reads_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_reads",
                                         name_y = "N Reads per Cell",
                                         fill = "dodgerblue")

# Reads per hto plot
g_read <- qc_violin_plot(meta,
                        category_x = "sample_hto_pool",
                        name_x = "HTO/Sample (singlets)",
                        column_y = "n_reads",
                        name_y = "N Reads per Cell, Singlets",
                        log_y = TRUE,
                        fill = "dodgerblue") +
  ggtitle("Reads per Cell")
# g_read

reads_violin_list <- list(category_reads_violins, 
                          g_read)
g_grid <- plot_grid(plotlist = reads_violin_list,
          ncol = 2, rel_widths = c(1, 1+n_samples/4),
          nrow = 1, align = "h")
          
                    
temp_figwidth = 3 + n_samples*0.4
temp_figheight = 4

batchreporter::make_subchunk(g_grid, subchunk_name = "sample_counts_violin_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, 
                                    warning = FALSE), 
              quiet_knit = TRUE)
``` 
  
[Return to Top](#top_cell_hashing)  

<a id="umi_counts_hto"></a> 

##### UMI Counts by HTO Category and Barcode  

```{r umi_counts, results = "asis"}
# UMI per category plot
stm("Generating umi count violin plots")
category_umis_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_umis",
                                         name_y = "N UMIs per Cell",
                                         fill = "purple")


# UMI per cell plot
g_umi <- qc_violin_plot(meta,
                        category_x = "sample_hto_pool",
                        name_x = "HTO/Sample (singlets)",
                        column_y = "n_umis",
                        name_y = "N UMIs per Cell, Singlets",
                        fill = "purple") +
  ggtitle("UMIs per Cell")
# g_umi


umis_violin_list <- list(category_umis_violins, 
                          g_umi)
g_grid <- plot_grid(plotlist = umis_violin_list,
          ncol = 2, 
          # rel_widths = c(1, 4),
          rel_widths = c(1, 1+n_samples/4),
          nrow = 1, align = "h")
          
temp_figwidth = 3 + n_samples*0.4
temp_figheight = 4

batchreporter::make_subchunk(g_grid, subchunk_name = "sample_umi_violin_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, 
                                    warning = FALSE), 
              quiet_knit = TRUE)

```   
  
[Return to Top](#top_cell_hashing)  
  
<a id="gene_counts_hto"></a> 

##### Gene Counts by HTO Category and Barcode  

```{r gene_counts, results = "asis"}
# Genes per category plot
category_genes_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_genes",
                                         name_y = "N Genes per Cell",
                                         fill = "orangered")
# Genes per cell plot
g_genes <- qc_violin_plot(meta,
                        category_x = "sample_hto_pool",
                        name_x = "HTO/Sample (singlets)",
                        column_y = "n_genes",
                        name_y = "N Genes per Cell, Singlets",
                        fill = "orangered") +
  ggtitle("Genes per Cell")


genes_violin_list <- list(category_genes_violins, 
                          g_genes)
g_grid <- plot_grid(plotlist = genes_violin_list,
          ncol = 2, 
          rel_widths = c(1, 1+n_samples/4),
          # rel_widths = c(1, 4),
          nrow = 1, align = "h")
          
temp_figwidth = 3 + n_samples*0.4
temp_figheight = 4

batchreporter::make_subchunk(g_grid, subchunk_name = "sample_genes_violin_subchunk", 
              chunk_opt_list = list(fig.height = temp_figheight, fig.width = temp_figwidth, 
                                    warning = FALSE), 
              quiet_knit = TRUE)

``` 
  
[Return to Top](#top_cell_hashing)  


scRNA hashing module v.`r {scrna_hashing_module_version}`
