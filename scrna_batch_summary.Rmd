---
title: "scRNA Seq Batch Summary: `r {params$batch}`"
author: 
 - Lauren Okada
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    self_contained: true
  tables: yes
params:
  in_dir: NULL
  batch: "B002"
  out_dir: NULL
---
<!-- <style> -->
<!--   .superbigimage{ -->
<!--       overflow-x:scroll; -->
<!--   } -->

<!--   .superbigimage img{ -->
<!--      max-width: none; -->
<!--   } -->

<!-- </style>  -->

```{css, echo=FALSE}

<style>

  .superbigimage{
      overflow-x:scroll;
      
  }

  .superbigimage img{
     max-width: none;
  }

</style>  
    
```

<!-- Set Up -->
```{r setup, echo = FALSE, include = TRUE}
# Load Libraries  
start_time <- Sys.time()

knitr::opts_chunk$set(echo = FALSE, cache = FALSE)

quiet_library <- function(...) {
  suppressPackageStartupMessages(library(...))
}
quiet_library(rhdf5)
quiet_library(H5weaver)
quiet_library(HTOparser)
quiet_library(Matrix)
quiet_library(ggplot2)
quiet_library(dplyr)
quiet_library(cowplot)
quiet_library(gt)  # formatted table output
quiet_library(plotly)  
quiet_library(immutils)
quiet_library(tidyr)
quiet_library(Seurat)
quiet_library(inflection)
quiet_library(future)
quiet_library(future.apply)

```

<!-- Argument parsing -->
```{r Parse arguments}
# if(is.null(params$in_dir)) {
#   in_dir <- system.file("testdata", package = "scrna-batch-summary")
#   out_h5 <- tempfile(fileext = ".h5")
#   out_tbl <- tempfile(fileext = ".csv.gz")
#   allow_few_cells <- FALSE
# } else {
#   in_h5 <- params$in_h5
#   out_h5 <- params$out_h5
#   out_tbl <- params$out_tbl
#   allow_few_cells <- as.logical(params$allow_few_cells)
#   
#   if(is.null(out_tbl)) {
#     out_tbl <- "Not Used"
#   }
# }
# 
# stm(paste0("IN  H5 file         : ", in_h5))
# stm(paste0("OUT H5 file         : ", out_h5))
# stm(paste0("OUT Cell Label Table: ", out_tbl))
```

```{r input_todelete}
# Delete this section after defining param structure
in_dir <- "~/rnaseq_qc_report/test_data/B002/rna/"
# in_dir <- "~/Projects/Exploration/B002/rna/"
in_dir2 <- "~/rnaseq_qc_report/test_data/B002/rna/hto"
# in_dir2 <- "~/Projects/Exploration/B002/rna/hto"
out_dir <- ""

```



```{r functions}
# NEEDS UPDATE CLOSER TO FINALIZATINO BASED ON LOCATIONS OF FUNCTIONS AND POTENTIALLY UPDATED PACKAGES
# values <- sample(1:100,10)

get_median_range <- function(values, digits_round = 1, add_missing = TRUE, verbose = TRUE){
  assertthat::assert_that(mode(values) == "numeric") # can be any type of numeric
  assertthat::assert_that(length(values) >= 1)
  
  i_missing <- which(is.na(values))
  has_missing <- length(i_missing)>0
  n_missing <- length(i_missing)
  
  if(has_missing){
    values <- values[-i_missing]
  }
  
  values_round <- round(values, digits_round)
  value_fmt <- paste0("%.",digits_round,"f")
  range_value_fmt <- paste0(value_fmt, "-", value_fmt)
  
  median <- sprintf(value_fmt, median(values_round))
  range <- sprintf(value_fmt, range(values_round))
  range_string <- paste(range, collapse = "-")
  median_range <- sprintf("%s (%s)", median, range_string)
  
  if(add_missing & has_missing){
    n_missing <- length(i_missing)
    median_range <- sprintf("%s [%s]", median_range, n_missing)
  }
  
  if(verbose){
    cat(sprintf("Median and range calculated. Removed %s missing values", n_missing), sep = "\n")
  }
  
  return(median_range)
}

# determine_passing_spec <- function(values, lower_threshold = NULL, upper_threshold = NULL, digits_round = 0, pass_at_threshold = TRUE){
#   assertthat::assert_that(mode(values) == "numeric")
#   assertthat::assert_that(length(values) >= 1)
#   
#   values_round <- round(values, digits_round)
#   
#   if(!is.null(lower_threshold)){
#     i_low <- which(values <= )
#   }
#   
#   if(pass_at_threshold){
#     i_low <- which(values_round < lower_threshold)
#   }
# 
# }

read_h5_well_meta <- function (h5_file, target = "well") {
  assertthat::assert_that(is.character(h5_file))
  assertthat::assert_that(length(h5_file) == 1)
  target <- ifelse(grepl("^/", target), target, paste0("/", 
                                                       target))
  h5_contents <- H5weaver::h5ls(h5_file)
  target_contents <- h5_contents[grepl(paste0("^", target,"$"), 
                                       h5_contents$group), ]
  h5_meta_targets <- target_contents$full_name
  
  if (length(h5_meta_targets) > 0) {
    meta_list <- lapply(h5_meta_targets, function(h5_meta_target) {
      rhdf5::h5read(h5_file, h5_meta_target)
    })
    rhdf5::h5closeAll()
    names(meta_list) <- sub(".+/", "", h5_meta_targets)
    meta_list <- strip_1d_array_recursive(meta_list)
    meta_list <- convert_char_na_recursive(meta_list)
    df <- as.data.frame(meta_list, stringsAsFactors = FALSE)
    if("well_id" %in% names(df)){
      df <- df[, c("well_id", setdiff(names(df),"well_id"))]
    }
    df
  }
  else {
    stop("No well metadata found in h5_file.")
  }
}

simple_html_table <- function(labels, values, col.names = NULL, col_widths_px = c(300,800), fontsize = 2){
  assertthat::assert_that(length(col_widths_px) %in% c(1,2))
  assertthat::assert_that(length(labels) == length(values))
  assertthat::assert_that(all(col_widths_px > 100) & all(col_widths_px < 1024))
  assertthat::assert_that(ifelse(is.null(col.names),TRUE, length(col.names) == 2))
  assertthat::assert_that(is.null(col.names) | class(col.names) == "character")
  
  if(length(col_widths_px) == 1){
    col_widths_px <- c(col_widths_px, col_widths_px)
  }

  create_row <- function(value1, value2 , col_widths_px = c(50, 50)){
    sprintf('<tr>
                <td style="width:%spx">
                  %s
                </td>
                <td style="width:%spx">
                  %s
                </td>
            </tr>',
            col_widths_px[1], value1, col_widths_px[2], value2)
  }

  add_table_wrap <- function(all_row_string, fontsize = 2, col_widths_px= c(50,50)){
    sprintf('<font size="%s">
            <style>
              table {
                border: 1px solid black;
                border-collapse: collapse;
              }
              td {
                padding: 5px;
                border: 1px solid black;
                border-collapse: collapse;
              }
            </style>
            <table>
              <colgroup>
                <col span="1" style="width: %spx;">
                <col span="1" style="width: %spx;">
              </colgroup>
              <tbody>
                %s
              </tbody>
            </table>
            </font>', fontsize, col_widths_px[1], col_widths_px[2], all_row_string)
  }
  
  row_strings <- character()
  for (i in seq_along(labels)){
    row_strings[i] <- create_row(labels[i], values[i], col_widths_px = col_widths_px)
  }
  row_string_all <- paste(row_strings, collapse = "")
  
  out_table <- add_table_wrap(row_string_all,fontsize = fontsize, col_widths_px = col_widths_px )
  
  htmltools::HTML(out_table)
}

get_gene_scores <- function(count_matrix, gene){
  gene_counts <- count_matrix[gene, ]
  return(gene_counts)
}

read_hto_well_json <- function(fp){
  assertthat::assert_that(length(fp) == 1)
  
  # keep_cols <- c("well_id", "hto_barcode", "hash_tag", "cutoff", "n_pos",
  #                "n_neg", "n_below_threshold", "frac_pos", "frac_neg", 
  #                "frac_below_threshold", "n_singlets","n_cells", "frac_cells")
  
  json_list <- jsonlite::read_json(fp)
  
  well_id <- json_list$well_id
  sample_stats_list <- json_list$pbmc_sample_hto_stats
  sample_stats_df_list <- lapply(seq_along(sample_stats_list), function(i){
    df <- data.frame(pbmc_sample_id = names(sample_stats_list)[i])
    stats_list <- lapply(sample_stats_list[[i]], function(x){
      ifelse(is.null(x),NA, x)
    })
    df <- cbind(df, as.data.frame(stats_list))
    df
  })
  
  sample_stats_df <- do.call(rbind, sample_stats_df_list)
  results <- data.frame(well_id = rep(well_id, nrow (sample_stats_df)),sample_stats_df)
}


qc_stacked_barplot_mod <- function (meta, category_x = "batch_id", name_x = "Batch ID", 
  category_y = "well_id", category_name = "Well ID", colorset_y = "varibow", 
  name_y = "N Cells", as_fraction = FALSE, facet_formula = NULL, facet_rows = NULL,...) {
  assertthat::assert_that(sum(class(meta) %in% c("data.frame", 
    "data.table")) > 0)
  assertthat::assert_that(class(category_x) == "character")
  assertthat::assert_that(length(category_x) == 1)
  assertthat::assert_that(category_x %in% names(meta))
  assertthat::assert_that(class(name_x) == "character")
  assertthat::assert_that(length(name_x) == 1)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(class(name_y) == "character")
  assertthat::assert_that(length(name_y) == 1)
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow", "varibow"))
  assertthat::assert_that(class(as_fraction) == "logical")
  assertthat::assert_that(length(as_fraction) == 1)
  meta <- as.data.table(meta)
  
  if(!is.null(facet_formula)){
    formula_cols <- as.character(as.list(facet_formula))
    f_cols <- setdiff(formula_cols, "`~`")
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
    category_y, f_cols))]
  } else {
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
    category_y))]
  }
  plot_xpos <- data.frame(unique(count_table[[category_x]]))
  names(plot_xpos) <- category_x
  plot_xpos <- plot_xpos[order(plot_xpos[[category_x]]), , 
    drop = FALSE]
  plot_xpos$xpos <- 1:nrow(plot_xpos)
  count_table <- count_table[plot_xpos, on = category_x]
  plot_fills <- data.frame(unique(count_table[[category_y]]))
  names(plot_fills) <- category_y
  if (colorset_y == "rainbow") {
    set.seed(3030)
    plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  else if (colorset_y == "varibow") {
    set.seed(3030)
    plot_fills$fill <- sample(immutils::varibow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  plot_fills <- plot_fills[order(plot_fills[[category_y]]), 
    ]
  count_table <- count_table[plot_fills, on = category_y]
  count_table <- count_table[order(get(category_y), decreasing = TRUE)]
  if (as_fraction) {
    count_table <- count_table[, `:=`(ymax, cumsum(n_cells)/sum(n_cells)), 
      by = list(get(category_x))]
    count_table <- count_table[, `:=`(ymin, shift(ymax, 
      fill = 0, type = "lag")), by = list(get(category_x))]
  }
  p <- ggplot2::ggplot() + ggplot2::geom_rect(data = count_table, 
    ggplot2::aes(xmin = xpos - 0.4, xmax = xpos + 0.4, ymin = ymin, 
      ymax = ymax, fill = fill)) + ggplot2::scale_fill_identity(category_name, 
    breaks = plot_fills$fill, labels = plot_fills[[category_y]], 
    guide = "legend") + ggplot2::scale_x_continuous(name_x, 
    breaks = plot_xpos$xpos, labels = plot_xpos[[category_x]]) + 
    ggplot2::scale_y_continuous(name_y) + ggplot2::theme_bw() + 
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, 
      hjust = 1, vjust = 0.3))
  if(!is.null(facet_formula)){
    p <- p +
      facet_wrap(facet_formula, nrow = facet_rows, ...)
  }
  p
}

qc_aligned_barplot_mod <- function (meta, category_x = "batch_id", 
                                    name_x = "Batch ID", 
                                    category_y = "well_id", 
                                    category_name = "Well ID", 
                                    colorset_y = "varibow", 
                                    name_y = "N Cells", padding = 0.2,
                                     facet_formula = NULL, facet_rows = NULL,...) {
  assertthat::assert_that(sum(class(meta) %in% c("data.frame", 
    "data.table")) > 0)
  assertthat::assert_that(class(category_x) == "character")
  assertthat::assert_that(length(category_x) == 1)
  assertthat::assert_that(category_x %in% names(meta))
  assertthat::assert_that(class(name_x) == "character")
  assertthat::assert_that(length(name_x) == 1)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(class(name_y) == "character")
  assertthat::assert_that(length(name_y) == 1)
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow", "varibow"))
  assertthat::assert_that(class(padding) == "numeric")
  assertthat::assert_that(length(padding) == 1)
  assertthat::assert_that(padding < 1)
  tidy_x <- rlang::parse_expr(category_x)
  tidy_y <- rlang::parse_expr(category_y)
  meta <- as.data.table(meta)
  if(!is.null(facet_formula)){
    formula_cols <- as.character(as.list(facet_formula))
    f_cols <- setdiff(formula_cols, "`~`")
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
                                                              category_y, f_cols))]
  } else {
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x, 
                                                              category_y))]
  }
  plot_xpos <- data.frame(unique(count_table[[category_x]]))
  names(plot_xpos) <- category_x
  plot_xpos <- plot_xpos[order(plot_xpos[[category_x]]), , 
    drop = FALSE]
  plot_xpos$xpos <- 1:nrow(plot_xpos)
  count_table <- count_table[plot_xpos, on = category_x]

  plot_fills <- data.frame(unique(count_table[[category_y]]))
  names(plot_fills) <- category_y
  if (colorset_y == "rainbow") {
    set.seed(3030)
    plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  else if (colorset_y == "varibow") {
    set.seed(3030)
    plot_fills$fill <- sample(immutils::varibow(nrow(plot_fills)), 
      nrow(plot_fills))
  }
  plot_fills <- plot_fills[order(plot_fills[[category_y]]), 
    ]
  count_table <- count_table[plot_fills, on = category_y]
  
  group_maxes <- count_table[, .(group_max = max(n_cells)), 
    by = list(get(category_y))]
  names(group_maxes)[1] <- category_y
  group_maxes <- group_maxes[order(get(category_y), decreasing = TRUE)]
  group_maxes <- group_maxes[, `:=`(cum_max, cumsum(group_max))]
  group_maxes <- group_maxes[, `:=`(group_center, cum_max - 
    group_max/2)]
  group_maxes <- group_maxes[, `:=`(padded_center, group_center + 
    (max(cum_max) * (padding/nrow(group_maxes))) * (1:nrow(group_maxes) - 
      1))]
  group_maxes <- group_maxes[, `:=`(padded_base, padded_center - 
    group_max/2)]
  group_maxes <- group_maxes[, `:=`(padded_top, padded_center + 
    group_max/2)]
  count_table <- count_table[group_maxes, on = category_y]
  count_table <- count_table[order(get(category_y), decreasing = TRUE)]
  count_table <- count_table[, `:=`(ymax, cumsum(n_cells)), 
    by = list(get(category_x))]
  count_table <- count_table[, `:=`(ymin, shift(ymax, fill = 0, 
    type = "lag")), by = list(get(category_x))]
  p <- ggplot2::ggplot() + 
    ggplot2::geom_rect(data = count_table, ggplot2::aes(xmin = xpos - 0.4, 
                                                        xmax = xpos + 0.4, 
                                                        ymin = padded_base, 
                                                        ymax = padded_base + n_cells, 
                                                        fill = fill)) + 
    ggplot2::geom_hline(data = count_table, ggplot2::aes(yintercept = padded_base)) + 
    ggplot2::geom_hline(data = count_table, ggplot2::aes(yintercept = padded_top), linetype = "dashed") + 
    ggplot2::scale_fill_identity(category_name, breaks = plot_fills$fill, 
                                 labels = plot_fills[[category_y]], guide = "legend") + 
    ggplot2::scale_x_continuous(name_x, breaks = plot_xpos$xpos, 
      labels = plot_xpos[[category_x]]) + 
    ggplot2::scale_y_continuous(name_y, breaks = c(group_maxes$padded_base, group_maxes$padded_top), 
                                labels = c(rep("", nrow(group_maxes)), group_maxes$group_max), 
                                expand = ggplot2::expansion(c(0, 0.02))) + ggplot2::theme_bw() + 
    ggplot2::theme(panel.grid.minor.y = ggplot2::element_blank(), 
                   axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, vjust = 0.3))
  
   if(!is.null(facet_formula)){
    p <- p +
      facet_wrap(facet_formula, nrow = facet_rows, ...)
  }
  p
}
```

```{r parse_input}

# Get list of all labeled h5 files
all_files <- list.files(path = in_dir, pattern = "_labeled.h5$", full.names = TRUE, recursive = TRUE)
all_hto_json <- list.files(path = in_dir, pattern = "hto_processing_metrics.json$", full.names = TRUE, recursive = TRUE)
all_split_json <- list.files(path = in_dir, pattern = "split_h5_metrics.json$", full.names = TRUE, recursive = TRUE)
all_multiplet <- list.files(path = in_dir2, pattern = "multiplet.h5$", full.names = TRUE, recursive = TRUE)


stm(paste0("IN Directory         : ", in_dir))
stm(paste0("IN Labeled H5 Files  :\n\t", paste(all_files, collapse = "\n\t")))
stm(paste0("IN JSON Files        :\n\t", paste(all_hto_json, collapse = "\n\t")))
stm(paste0("IN Multiplet H5 Files:\n\t", paste(all_multiplet, collapse = "\n\t")))


```


```{r merge_meta}
# Merge Metadata
stm("Reading in labeled h5 file meta data")
meta_list <- lapply(all_files, read_h5_cell_meta)
meta <- do.call(rbind, meta_list)
setDT(meta)
remove("meta_list")
```

```{r merge_well}
# Merge Well Data
stm("Reading in labeled h5 file well data")
well_list <- lapply(all_files, read_h5_well_meta)
well_info <- unique(do.call(rbind, well_list))
setDT(well_info)

remove("well_list")
```  

```{r read_json}
# Read in json files
stm("Reading in hto processing metrics json files")
well_hto_json_list <- lapply(all_hto_json,read_hto_well_json)
well_hto_json_df <- do.call(rbind, well_hto_json_list)
well_hto_json_df <- well_hto_json_df %>% 
  mutate(sample_hto = paste(hto_barcode, pbmc_sample_id, sep = "\n")) %>% 
  mutate(pool_id_short = gsub(".*-", "", gsub("C.*","", well_id))) %>% 
  mutate(pool_id = gsub("C.*","", well_id)) %>% 
  mutate(sample_pool = paste(pbmc_sample_id, pool_id_short, sep = "_")) %>% 
  mutate(sample_pool_hto = paste(sample_pool, hto_barcode, sep = "\n"))
remove("well_hto_json_list")
```

```{r read_multiplet}
stm("Reading in multiplet h5 file meta data")
multiplet_meta_list <- lapply(all_multiplet, read_h5_cell_meta)
multiplet_meta <- do.call(rbind, multiplet_meta_list)
setDT(multiplet_meta)
all_meta <- merge(meta, multiplet_meta, all = TRUE)
  # dplyr::full_join(multiplet_meta)  # todo: clean up formatting
remove("multiplet_meta_list","multiplet_meta")
```


```{r merge_counts}
# # Merge counts
# count_mat_list <- lapply(all_files, read_h5_dgCMatrix, "matrix")
# count_mat_list2 <- lapply(all_files[1], read_h5_dgCMatrix, "matrix",)
```

```{r fix_p1_meta_todelete }
meta[, ":="(pool_id = gsub("C.*", "", pool_id),
            well_id = gsub("-RNA", "", well_id),
            batch_id = gsub("-.*", "", batch_id))]
all_meta[, ":="(pool_id = gsub("C.*", "", pool_id),
            well_id = gsub("-RNA", "", well_id),
            batch_id = gsub("-.*", "", batch_id))]
well_info[, ":="(well_id = gsub("-RNA", "", well_id))]
```

```{r add_vars_meta }
meta[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
meta[ ,pbmc_sample_pool:= sprintf("%s_%s", pbmc_sample_id, pool_id)]
meta[ ,plot_barcode:= sprintf("%s\n%s", hto_barcode, pbmc_sample_pool)]
all_meta[, ":="(fct_mito_umi = n_mito_umis/n_umis)]
all_meta[ ,pbmc_sample_pool:= sprintf("%s_%s", pbmc_sample_id, pool_id)]
all_meta[ ,plot_barcode:= sprintf("%s\n%s",hto_barcode, pbmc_sample_pool)]
well_info[, ":="(well_id = gsub("-RNA", "", well_id))]
```

## Batch Information    
```{r batchinfo, include = TRUE }
# Summarize batch information
batch <- unique(meta$batch) # assumption is one batch per report

pools <- unique(meta$pool_id)
n_pool <- length(pools)

samples <- unique(meta$pbmc_sample_id)
n_samples <- length(samples)

control_sample_pattern <- "^IMM\\d{2}_\\d{3}$"

controls <- grep(control_sample_pattern, samples, value = T)
has_controls <- length(controls) > 0 

if (has_controls){
  sub_samples <- setdiff(samples, controls)
} else {
  sub_samples <- samples
}

n_sub_samples <- length(sub_samples)

samples_pool <- tapply(meta$pbmc_sample_id, meta$pool_id, unique)
samples_pool_string <- sapply(samples_pool, function(x){paste(x, collapse = ", ")})

labels <- c("Batch", "N Samples", "N Pools", paste0(pools, " Samples"))
values <-  c(batch, n_sub_samples, n_pool, samples_pool_string)

simple_html_table(labels, values, fontsize = 3, col_widths_px = c(175, 850))

```  

```{r fig_dims}
fig_height_samples_4col <- ceiling(n_samples/4)*1.5

fig_height_samples_each_row <- n_samples*1.5

fig_width_n_pools <- n_pool*8

```  

## QC Results Summary  
```{r echo_qc_summary_chunk, ref.label = "qc_summary" }
# Placeholder for high-level summary (can't calculate everything until end)
```  

<a  id="section_top"></a>  

## Summary Details {.tabset}  

### Well Sequencing and Alignment {.active}  
  
The following metrics summarize the sequencing and alignment by 10x well prior to un-hashing and hash-based cell filtering.  
  
#### Detailed Well Summary  
```{r well_summary_table, results = "as-is"}
n_vars <- ncol(well_info)-1
varnames <- names(well_info)[-1]
digitsRound <- c(0,1,rep(0,4),rep(1,12),0,1)
names(digitsRound) <- varnames
well_info_median_range <- sapply(varnames,function(x){get_median_range(values = well_info[[x]], digits_round = digitsRound[x], verbose = F)})
well_info_median <- lapply(well_info[,-"well_id"], median)
well_info_median_fmt <- as.character(well_info_median)
well_info_cv <- sapply(well_info[,-"well_id"], function(x){round(sd(x)/mean(x)*100,1)})

well_summary_table <- data.frame(Spec = varnames, 
                                 `Median_Range` = well_info_median_range,
                                 `Inter_Well_CV` = well_info_cv)
# well_summary_table_comments <- flag_well_summary(well_summary_table)  # Eventual function to perform well-specific flagging based on summary values
well_summary_table_comments <- well_summary_table
set.seed(1105)
dummycomments <- sample(c("","Warning: message","Fail: message"),
                        size = nrow(well_summary_table_comments), 
                        replace=T, prob = c(0.85,0.12,0.03))
well_summary_table_comments$Comments <- dummycomments
well_summary_table_comments$Plot <- sprintf("[Plot](#%s)", varnames)

gt_fmt_comments <- function(x) {
  x %>% 
    gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.3)
      ),
    locations = cells_body(
      columns = vars(Comments),
      rows = grepl("Warning",Comments))
  ) %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.5)
      ),
    locations = cells_body(
      columns = vars(Comments),
      rows = grepl("Fail",Comments))
  ) 
}

well_summary_table_comments %>% 
  gt::gt() %>% 
  gt::fmt_markdown(columns = "Plot") %>% 
  gt::fmt_number(columns = vars(Inter_Well_CV), pattern = "{x}%", decimals = 1) %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.3)
      ),
    locations = cells_body(
      columns = vars(Inter_Well_CV),
      rows = Inter_Well_CV >= 10)
  ) %>% 
  gt_fmt_comments()
  # gt::tab_style(
  #   style = list(
  #     cell_fill(color = "red" , alpha = 0.3)
  #     ),
  #   locations = cells_body(
  #     columns = vars(Comments),
  #     rows = grepl("Warning",Comments))
  # ) %>% 
  # gt::tab_style(
  #   style = list(
  #     cell_fill(color = "red" , alpha = 0.5)
  #     ),
  #   locations = cells_body(
  #     columns = vars(Comments),
  #     rows = grepl("Fail",Comments))
  # ) 
  #                         

```  
  
#### Plots of Well-Level Metrics  
  
```{r well_plots, results = "asis"}
bar_theme <- function(...){
  ggplot2::theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), ...)
}
verpal <- hcl.colors(n = n_vars, palette = "viridis")

# Plots
for (i in seq_along(varnames)){
  df <- data.table::copy(well_info)
  spec <- varnames[i]
  # spec_lab <- well_spec_labels[i]
  df <- as.data.frame(df)
  df$spec_col <- df[,spec]
  med_val <- median(df$spec_col)
  cv <- round(sd(df$spec_col)/mean(df$spec_col)*100,2)
  n <- sum(!is.na(df$spec_col))
  
  g <- ggplot(df, aes(well_id, spec_col)) +
    geom_bar(stat = "identity", fill = verpal[i]) + 
    bar_theme() +
    geom_hline(yintercept = med_val, linetype = "dashed", color = "red")+
    scale_y_continuous(sec.axis = dup_axis(breaks = med_val, labels = med_val, name = ""))+
    xlab("Well") +
    ylab(spec) +
    ggtitle(sprintf("%s\nMedian=%s    CV=%.1f%%    N=%s", spec, med_val, cv, n))

  cat(sprintf('\n<a id="%s"></a>', spec), labels = "", sep = "\n")
  suppressWarnings(print(g))
  
  # cat("  ", labels = "", sep = "\n")
  cat("  \n[Return to Top](#section_top)", labels = "", sep = "\n")
  # cat(sprintf("\n[Return to Table](#%s)  ",spec), labels = "", sep = "\n")
  
  # gHist <- ggplot(df, aes(spec_col)) +
  #   geom_histogram(fill = verpal[i], bins = 10) +
  #   geom_vline(xintercept = med_val, linetype = "dashed", color = "red")+
  #   xlab(spec) +
  #   ggtitle(sprintf("%s\nMedian=%s    CV=%.1f%%    N=%s", spec, med_val, cv, n))
  # suppressWarnings(print(ggHist))
  #
  # g_grid <- cowplot::plot_grid(g, gHist, nrow = 1, rel_widths = c(4,3))
  # suppressWarnings(print(g_grid))
}

``` 
 
### Cell Hashing  
<a id="top_cell_hashing"></a> 

```{r cell_hashing}
# # Merge hashing info
# hash_list <- lapply(all_files, read_h5_dgCMatrix, target = "hash")
# names(hash_list)
# 
# h5_test <- h5dump(all_files[[1]])
# h5test2 <- h5_list_convert_to_dgCMatrix(h5_test, target = "hash")
# hash_mat <- h5test2[["hash_dgCMatrix"]]

```  

```{r hashing_summary}
dummy_blank <- rep("x",5)
dummy_table <- data.frame("Specification"=dummy_blank, 
                          "Value"= dummy_blank,
                          "Comments"=c("","","Warning: message","Fail: mesage",""))
dummy_table %>% 
  gt() %>% 
  gt_fmt_comments

fig_width <- n_samples*0.75

```

#### HTO Assignment Cutoffs 
```{r hto_assignment, fig.height = 6, fig.width = n_samples*0.4}
# cutoffs <- well_hto_json_df %>% 
#   dplyr::group_by(hto_barcode, pbmc_sample_id, sample_hto, pool_id) %>% 
#   dplyr::summarize(n_wells = n(),
#                    median_cutoff = median(cutoff),
#                    cv_cutoff = sd(cutoff)/mean(cutoff)*100)
# cutoffs

g_cutoff_box <- ggplot(well_hto_json_df, aes(sample_hto, cutoff, color = hto_barcode)) +
  suppressWarnings(geom_point(alpha = 0.4, position = position_jitter(height = 0, width = 0.3, seed = 20201112),
             aes(text = sprintf("Well ID: %s",  well_id)))) +
  geom_boxplot(alpha = 0, outlier.alpha = 1, color = "black") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        axis.title.x = element_text(margin = margin(c(15,0,1,0)))) +
  facet_grid(~pool_id, drop = TRUE, scales = "free_x")+
  ggtitle("Well-Specific HTO Cutoffs") 

ply_cutoff_box <- plotly::ggplotly(g_cutoff_box)
ply_cutoff_box

```  
[Return to  Top](#top_cell_hashing)  
  
```{r hto_pos_cutoff, fig.width = n_samples*0.4, fig.height = 6}
g_cutoff_pos <- ggplot(well_hto_json_df, aes(sample_hto, frac_pos, color = hto_barcode)) +
  suppressWarnings(geom_point(alpha = 0.4, position = position_jitter(height = 0, seed = 20201112),
             aes(text = sprintf("Well ID: %s",  well_id)))) +
  geom_boxplot(alpha = 0, outlier.alpha = 1, color = "black") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
                axis.title.x = element_text(margin = margin(c(15,0,1,0)))) +
  facet_grid(~pool_id, drop = TRUE, scales = "free_x")+
  ggtitle("Fraction Positive HTO Calls per Well")
ply_cutoff_pos <- plotly::ggplotly(g_cutoff_pos) 
ply_cutoff_pos
```  
[Return to Top](#top_cell_hashing)  

#### HTO Category Counts by Well  
```{r hto_cat_counts}
# hto_cat <- all_meta %>% 
#   group_by(well_id, pool_id, hto_category) %>% 
#   summarise(N = n(), .groups = "drop") %>% 
#   tidyr::spread(key = hto_category, value = N) 
  
qc_aligned_barplot_mod(all_meta,
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "hto_category",
                   category_name = "HTO Category",
                   colorset_y = "varibow",
                   name_y = "N Cells",
                   padding = 0.2, 
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_x") +
  ggtitle("HTO Category Counts per Well")
  
```  

[Return to Top](#top_cell_hashing)


#### HTO Category Fraction by Well
```{r hto_cat_fractions, fig.width = fig_width_n_pools, fig.height = 6}
# hto_cat <- all_meta %>% 
#   group_by(well_id, pool_id, hto_category) %>% 
#   summarise(N = n(), .groups = "drop") %>% 
#   tidyr::spread(key = hto_category, value = N) 
qc_stacked_barplot_mod(all_meta,
                       category_x = "well_id",
                       name_x = "Well ID",
                       category_y = "hto_category",
                       category_name = "HTO Category",
                       colorset_y = "varibow",
                       name_y = "Fraction of Cells",
                       as_fraction = TRUE, facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_x") +
  ggtitle("HTO Category Counts per Well")

  
```

[Return to Top](#top_cell_hashing)

#### Singlet Summaries (hash-based)  
##### HTO Barcode Count per Well Plot  

```{r hto_counts_well,  fig.width = fig_width_n_pools, fig.height = 6}
plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_aligned_barplot_mod(meta = meta[meta$pool_id == pools[i]],
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "plot_barcode",
                   category_name = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   padding = 0.2) +#,
                   # facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_y", drop = TRUE) +
  ggtitle(pools[i])

}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)

```  
##### HTO Barcode Fraction per Well Plot  

```{r hto_fraction_well,  fig.width = fig_width_n_pools, fig.height = 6}
plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_stacked_barplot_mod(meta = meta[pool_id==pools[i]],
                   category_x = "well_id",
                   name_x = "Well ID",
                   category_y = "plot_barcode",
                   category_name = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   as_fraction = TRUE, 
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales = "free_x") +
  ggtitle("HTO Barcode Fraction per Well")
}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)
  
```  

##### Well Fraction per HTO Barcode Plot  
```{r Well Fraction By HTO Barcode Plot, fig.height = 6, fig.width = fig_width_n_pools}
plot_list <- list()
for (i in seq_along(pools)){
  plot_list[[i]] <- qc_stacked_barplot_mod(meta = meta[pool_id == pools[i],],
                   category_x = "plot_barcode",
                   category_y = "well_id",
                   category_name = "Well ID",
                   name_x = "HTO Barcode",
                   colorset_y = "varibow",
                   name_y = "Fraction of Cells",
                   as_fraction = TRUE , 
                   facet_formula = formula("~pool_id"), facet_rows = 1, scales ="free_x", drop = TRUE) +
  ggtitle("Well Fraction per HTO Barcode")
}

cowplot::plot_grid(plotlist = plot_list, nrow = 1)


```  
[Return to Top](#top_cell_hashing)  
  
##### Counts by HTO Category and Barcode  
```{r read_counts, height = 5, width = 12}
# Reads per hto cat
category_reads_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_reads",
                                         name_y = "N Reads per Cell",
                                         fill = "dodgerblue")
# Reads per hto plot
g_read <- qc_violin_plot(meta,
                        category_x = "plot_barcode",
                        name_x = "HTO Barcode (singlets)",
                        column_y = "n_reads",
                        name_y = "N Reads per Cell",
                        log_y = TRUE,
                        fill = "dodgerblue") +
  ggtitle("Reads per Cell")
# g_read

reads_violin_list <- list(category_reads_violins, 
                          g_read)
plot_grid(plotlist = reads_violin_list,
          ncol = 2, rel_widths = c(1, 4),
          nrow = 1, align = "h")
``` 
  
[Return to Top](#top_cell_hashing)  

```{r umi_counts}
# UMI per category plot
category_umis_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_umis",
                                         name_y = "N UMIs per Cell",
                                         fill = "purple")


# UMI per cell plot
g_umi <- qc_violin_plot(meta,
                        category_x = "plot_barcode",
                        name_x = "HTO Barcode (singlets)",
                        column_y = "n_umis",
                        name_y = "N UMIs per Cell",
                        fill = "purple") +
  ggtitle("UMIs per Cell")
# g_umi


umis_violin_list <- list(category_umis_violins, 
                          g_umi)
plot_grid(plotlist = umis_violin_list,
          ncol = 2, rel_widths = c(1, 4),
          nrow = 1, align = "h")

```   
  
[Return to Top](#top_cell_hashing)  
  
```{r gene_counts}
# Genes per category plot
category_genes_violins <- qc_violin_plot(all_meta,
                                         category_x = "hto_category",
                                         name_x = "HTO Category",
                                         column_y = "n_genes",
                                         name_y = "N Genes per Cell",
                                         fill = "orangered")
# Genes per cell plot
g_genes <- qc_violin_plot(meta,
                        category_x = "plot_barcode",
                        name_x = "HTO Barcode (singlets)",
                        column_y = "n_genes",
                        name_y = "N Genes per Cell",
                        fill = "orangered") +
  ggtitle("Genes per Cell")


genes_violin_list <- list(category_genes_violins, 
                          g_genes)
plot_grid(plotlist = genes_violin_list,
          ncol = 2, rel_widths = c(1, 4),
          nrow = 1, align = "h")

``` 
  
[Return to Top](#top_cell_hashing)  
    
### Cell Labeling  

<a id="top_cell_labeling"></a> 

```{r cell_labeling_summary}
dummy_table %>% 
  gt() %>% 
  gt_fmt_comments()


```  

#### UMAP  
```{r combine count matrices for all samples}
stm("Reading and merging all count matrices")

# Merge the count matrices for all samples into 1 table
avail_workers <- as.numeric(future::availableCores())
future::plan("multiprocess", workers = avail_workers)

all_counts_list <- future.apply::future_lapply(all_files[1:5], H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
# all_counts_list <- lapply(all_files, H5weaver::read_h5_dgCMatrix, target = "matrix", feature_names = "name")
all_counts_mat <- do.call(cbind, all_counts_list)
all_counts_cells_bc <- meta$original_barcodes

featDF <- read_h5_feature_meta(all_files[1])

rm("all_counts_list")
```  

```{r combined_umap}
stm("Creating Seurat object from merged data")
# Create Seurat object
merged_so <- Seurat::CreateSeuratObject(counts = all_counts_mat)

stm("Normalizing data")
plan("sequential")  # reverting to sequential to avoid error
# Normalize data
merged_so <- Seurat::NormalizeData(object = merged_so, 
                                   normalization.method = "LogNormalize",
                                   scale.factor = 10000,
                                   margin = 1)

normCounts <- merged_so[["RNA"]]@data

```

```{r}
# library(SeuratLabeler)
# reference_so <- variable_pbmc_10k_v3
# transfer_anchors <- FindTransferAnchors(reference = reference_so,
#                                         query = merged_so,
#                                         normalization.method = "LogNormalize",
#                                         features = VariableFeatures(object = reference_so),
#                                         reduction = "pcaproject")


```  


```{r PCA}
pc_dims <- min(ncol(merged_so) - 1, 50)

stm("Finding Variable Features")

merged_so <- FindVariableFeatures(object = merged_so)

stm("Scaling Data")
merged_so <- ScaleData(object = merged_so)

stm("Running PCA")
merged_so <- RunPCA(object = merged_so, npcs = pc_dims)  

# save pca object
# saveRDS(merged_so, file = "merged_so_pcaresults.rds")
# merged_so <- readRDS("merged_so_pcaresults.rds")
 
```  


```{r jackstraw_pc_selection }

# Jackstraw Method
# sample_cells <- function(cl,
#                           sample.size,
#                           seed = 3030) {
#   cl.cells <- split(names(cl), cl)
#   sampled.cells <- sapply(names(cl.cells), function(x) {
#     cells <- cl.cells[[x]]
#     if (sample.size >= length(cells)) {
#       return(cells)
#     }
#     to.sample <- pmin(sample.size, length(cells))
# 
#     set.seed(seed)
#     sample(cells, to.sample)
#   }, simplify = FALSE)
#   sampled.cells <- unlist(sampled.cells)
#   return(sampled.cells)
# }
# 
# submerged <- meta %>%
#   filter(barcodes %in% rownames(merged_so[["RNA"]]@meta.features))
# predicted <- submerged$seurat_pbmc_type
# names(predicted) <- submerged$barcodes
# jackstraw_cells <- sample_cells(predicted, 100)
# jackstraw_so <- merged_so[,jackstraw_cells]
# 
# jackstraw_so <- JackStraw(object = jackstraw_so,
#                           dims = pc_dims,
#                           num.replicate = 50,
#                           verbose = FALSE)
# jackstraw_so <- ScoreJackStraw(object = jackstraw_so,
#                                dims = 1:pc_dims)
# 
# pc_pvals <- jackstraw_so@reductions$pca@jackstraw$overall.p.values[,2]
# good_pcs <- pc_pvals < 0.05
# 
# pc_embeddings <- merged_so@reductions$pca@cell.embeddings
```


```{r elbowplot_pc_selection}
stm("Determining dimensionality via elbow plot method")

# Elbow Method
pcElbow <- Seurat::ElbowPlot(object = merged_so,reduction = "pca")

# Find inflection point of the elbow curve
inflectionPoint <- inflection::ede(x = pcElbow$data$dims,
                                   y = pcElbow$data$stdev,
                                   index = 1)[, "j2"]
pc_var <- (merged_so@reductions$pca@stdev)^2
cumvar <- cumsum(pc_var/sum(pc_var))
p_elbow <- pcElbow +
  geom_vline(xintercept = inflectionPoint, col = "red") +
  geom_text(x = inflectionPoint, col = "red", y = Inf,
            label = sprintf("PC%s: Cum.Prop. Variance = %0.3f", inflectionPoint, round(cumvar[inflectionPoint],3)), 
            check_overlap = T, hjust = -0.1, vjust = 1) +
  ggtitle(sprintf("PC Elbow Plot"))
plot(p_elbow)

pc_embeddings <- merged_so@reductions$pca@cell.embeddings
```


```{r merged_umap}

# Run UMAP
stm("Running UMAP on selected coordinates...")
## As the number of dimensions, use the same PCs as input to the clustering analysis
# umap_results <- uwot::umap(pc_embeddings[, 1:inflectionPoint],
#                            min_dist = 0.1)

merged_so_elbow <- Seurat::RunUMAP(merged_so,
                                   dims = 1:inflectionPoint,
                                   # umap.method = "umap-learn",
                                   umap.method = "uwot",
                                   seed.use = 3,
                                   verbose = TRUE)
# saveRDS(merged_so_elbow, file = "merged_so_elbow.Rds")
```

```{r recover_analysis }
# merged_so <- readRDS("merged_so_pcaresults.rds")
# merged_so_elbow <- readRDS("merged_so_elbow.Rds")
```


```{r umap_cleanup}
# # Get UMAP coordinates
# umapDF <- umap_results %>%
#           as.data.frame() %>%
#           dplyr::rename(UMAP_1_merged = V1, UMAP_2_merged = V2) %>%
#           # tibble::rownames_to_column(var = "barcodes")
#           dplyr::mutate(barcodes = rownames(pc_embeddings))
# # umapDF <- merge(umapDF, merged_so_elbow@"meta.data", by = "barcodes")
# umapDF <- merge(umapDF, meta, by = "barcodes")
# rownames(umapDF) <- umapDF$barcodes

# Get UMAP coordinates
umapDF <- merged_so_elbow[["umap"]]@cell.embeddings %>%
          as.data.frame() %>%
          dplyr::rename(UMAP_1_merged = UMAP_1, UMAP_2_merged = UMAP_2) %>%
          tibble::rownames_to_column(var = "barcodes")
umapDF <- merge(umapDF, meta, by = "barcodes")
rownames(umapDF) <- umapDF$barcodes
umapDF <- umapDF[rownames(merged_so_elbow@"meta.data"), , drop = F]

normCounts <-merged_so[["RNA"]]@data
assertthat::assert_that(all(rownames(umapDF) == colnames(normCounts)))

```  
[Return to Top](#top_cell_labeling)  
  
UMAP Cell Visualizations

```{r umap_cells, fig.height = 18, results = "asis"}
stm("Plotting Batch UMAP by Various Groupings")

cell_type_palette <- data.frame(
  seurat3_pbmc_type = c("B cell progenitor", "CD14+ Monocytes", "CD16+ Monocytes",
                       "CD4 Memory", "CD4 Naive","CD8 effector", "CD8 Naive", 
                       "Dendritic cell", "Double negative T cell", "NK cell",
                       "pDC", "Platelets", "pre-B cell"),
  cell_color = c("#FF0000","#FF8C00","#FFEE00","#44FF00", "#00E1FF","#0000FF",
                 "#E546FA","#F598E5","#008A12", "#803CCF", "#967729", "#B1C4F0",
                 "#DCF0B1"), 
  stringsAsFactors = FALSE
)

# Gene scaling
# min_genes <- min(100, meta$n_genes)
max_genes <- max(8000,meta$n_genes)
max_umi <- max(60000,meta$n_umis)
point_size <- 0.1

# Cell Types
g_base <- ggplot(umapDF, aes(UMAP_1_merged, UMAP_2_merged)) 

stm("Plotting cell type UMAP")
g1 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = seurat_pbmc_type)) +
  ggtitle("Cell Labels")+
  scale_color_manual(values = cell_type_palette$cell_color, 
                     breaks = cell_type_palette$seurat3_pbmc_type) +
  theme_bw() +
  theme(legend.key.size = unit(1, 'lines'))+
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Labeling Scores
stm("Plotting Labeling Score UMAP")
g2 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = seurat_pbmc_type_score)) +
  ggtitle("Label Scores")+
  scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
                        breaks = c(0,0.25,0.5,0.75,1)) +
  theme_bw()

# fraction mitochondrial umi
stm("Plotting Fraction Mito UMAP")
g3 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = fct_mito_umi)) +
  ggtitle("Fraction Mitochondrial UMIs")+
  scale_color_gradientn(limits = c(0,1),colours = c("blue", "green3","yellow","red"),
                        breaks = c(0,0.25,0.5,0.75,1)) +
  theme_bw()

# N Genes
stm("Plotting N Genes UMAP")
g4 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = n_genes)) +
  ggtitle("Gene Counts")+
  scale_color_gradientn(limits = c(0, max_genes),
                        colours = c("blue","deepskyblue","green3", "yellow","orange","red","darkred"),
                        values = scales::rescale(c(0,500, 1000, 2000, 3000, 4000, max_genes),
                                                 from = c(0, max_genes)),
                        breaks = c(0,2000,4000,6000,8000)) +
  theme_bw()

# N UMIs
stm("Plotting N UMIs UMAP")
g5 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = n_umis)) +
  ggtitle("UMI Counts")+
  scale_color_gradientn(limits = c(0,max_umi),
                        colours = c("blue","deepskyblue","green3", "yellow","orange","red","darkred"),
                        values = scales::rescale(c(0,1000, 3000, 5000, 7500, 10000, max_umi),
                                                 from = c(0, max_umi))) +
  theme_bw()

# Wells
stm("Plotting Well UMAP")
cols_well <- immutils::varibow(n_colors = length(unique(umapDF$well_id)))
g6 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = well_id)) +
  ggtitle("Well ID") +
  scale_color_manual(values = cols_well)+
  theme_bw() +
  theme(legend.key.size = unit(1, 'lines')) +
  guides(colour = guide_legend(override.aes = list(size = 3)))

# Sample
stm("Plotting Sample ID UMAP")
cols_sample <- immutils::varibow(n_colors = length(unique(umapDF$pbmc_sample_id)))
g7 <- g_base +
  geom_point(alpha = 1, size = point_size, aes(color = pbmc_sample_id)) +
  ggtitle("Sample ID")+
  scale_color_manual(values = cols_sample)+ 
  theme_bw()+
  theme(legend.key.size = unit(1, 'lines'))+
  guides(colour = guide_legend(override.aes = list(size = 3)))

aligned_plots <- cowplot::align_plots(g1, g2, g3, g4, g5, g6, g7, align = "hv", axis = "tblr")  # uniform plot sizing 

cowplot::plot_grid(aligned_plots[[1]],
                   aligned_plots[[2]],
                   aligned_plots[[3]],
                   aligned_plots[[4]],
                   aligned_plots[[5]],
                   aligned_plots[[6]],
                   aligned_plots[[7]],
                   ncol = 2)

```  

[Return to Top](#top_cell_labeling) 


#### Seurat Labeling Scores  
```{r cell_labeling}
stm("Plotting Seurat labeling score distributions")
# score_breaks <- c(0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, Inf)
# score_labels <- c("0-0.25", ">0.25-0.5", ">0.5-0.75", ">0.75-0.9", ">0.9-0.95",">0.95-0.99",">0.99")
# meta[, score_bin := cut(seurat_pbmc_type_score, breaks = score_breaks, labels = score_labels, include.lowest = T)]
# 
# meta_label_sample_score <- as.data.frame(meta) %>% 
#   group_by(pbmc_sample_id, seurat_pbmc_type, score_bin) %>% 
#   summarize(N = n(), .groups = "drop") %>% 
#   ungroup() %>% 
#   group_by(pbmc_sample_id) %>% 
#   mutate(pct_by_sample = N/n()*100)
# 
# ggplot(meta_label_sample_score, aes(seurat_pbmc_type, N, fill = score_bin)) +
#   geom_bar(stat = "identity")+
#   facet_wrap(~pbmc_sample_id) +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1))

# quality scores by sample
meta_sample <- meta[ ,.(median_quality = median(seurat_pbmc_type_score)), by = pbmc_sample_id]

meta_label <- meta[ ,.(median_quality = median(seurat_pbmc_type_score)), by = seurat_pbmc_type]
meta_label[, median_quality_label := sprintf("median = %.3f", round(median_quality,3))]

# seurat3_pbmc_cell_type_cols <- c()
ggplot(meta, aes(seurat_pbmc_type_score, fill = seurat_pbmc_type)) +
  geom_histogram(bins = 30) +
  scale_color_discrete() +
  scale_x_continuous(limits =c(-0.01,1.01)) +
  geom_text(data = meta_label, x = -Inf, y = Inf, hjust = 0, vjust = 1, aes(label = median_quality_label))+
  ggtitle("Label Quality Score by Cell Label Type") +
  facet_wrap( ~ seurat_pbmc_type) 
  # facet_wrap(seurat_pbmc_type ~ pbmc_sample_id)

```



### Marker Visualization  

```{r marker_umap, fig.width = 10, fig.height=fig_height_samples_4col}
stm("Plotting UMAP of marker genes")
genes <- c("CD3E", "CD4", "CD8A", "HLA-DRA", "CD14", "FCGR3A", "IL3RA", "ITGAX", 
           "CD19", "MS4A1", "CD79A", "NCAM1", "NKG7", "PPBP")
cDF <- normCounts
# rownames(cDF) <- featDF$name[featDF$id == rownames(cDF)]
markerDF <- t(cDF[genes, ]) %>% as.data.frame()
umapDF2 <- umapDF[, c("UMAP_1_merged", "UMAP_2_merged")]
# table(rownames(markerDF) == rownames(umapDF2))
umapDF2 <- cbind(umapDF2, markerDF) %>%
           tidyr::gather(key = gene, value = value, -UMAP_1_merged, -UMAP_2_merged)
umapDF2$gene <- factor(umapDF2$gene, levels = genes)

# plot UMAP per marker
marker_umap_l <- list()
for(G in genes) {
  umapDF3 <- umapDF2 %>% dplyr::filter(gene %in% G)
  # outFile <- paste("UMAP_MarkerExpression_", G, ".pdf", sep = "")
  marker_umap_l[[G]] <- ggplot(data = umapDF3,
                               mapping = aes(x = UMAP_1_merged, 
                                             y = UMAP_2_merged, 
                                             color = as.numeric(value))) +
    geom_point(size = 0.8) +
    scale_color_gradient(low = "white", high = "red") +
    labs(x = "UMAP 1", y = "UMAP 2") +
    labs(color = "NormCount") +
    facet_wrap(~gene) +
    theme(strip.text = element_text(size = 12),
          panel.background = element_rect(fill = "#b6b7b2"),
          axis.text.x = element_text(size = 10, color = "black"),
          axis.text.y = element_text(size = 10, color = "black"),
          axis.line = element_line(color = "grey"),
          panel.grid = element_blank())
  # pdf(file = outFile, width = 7, height = 7)
  # print(plotumap)
   # dev.off()
}

cowplot::plot_grid(plotlist = marker_umap_l, ncol = 4)


```

 
```{r umap_cd4, fig.width = 10, fig.height=fig_height_samples_4col}

# cd4_count_list <- lapply(count_mat_list, get_gene_scores, gene = "ENSG00000010610")
# cd4 <- unlist(cd4_count_list)
# cd4_log10 <- log10(cd4)
# cd4_log10 <- ifelse(is.finite(cd4_log10), cd4_log10 + 1, 0)
# 
# ggplot(cbind(meta,cd4_log10), aes(umap_1, umap_2)) + 
#   geom_point(alpha = 0.7, aes(color = cd4_log10)) +
#   scale_color_gradient2(low = "blue", mid = "yellow", high = "red", midpoint = 1) +
#   facet_wrap(~paste0(pbmc_sample_id,"\n",pool_id), ncol = 4)

```  

### Leukopak Control  
```{r control_summary}
dummy_table %>% 
  gt() %>% 
  gt_fmt_comments()


```  

<!-- Batch Summary QC Executed here, referenced in "echo_qc_summary_chunk" above to allow display in first tab -->
```{r qc_summary, results = "hide"}
# qcCriteria <- c("Cells per Well, Count [Median (Range)]", "Cells per Well, Variation [CV]")
# qcCriteriaLevel <- c("Well", "Well")
# qcValues <- c("31239 [12312-4153151]", "34.5%")

# final_qc <- data.table(`QC Level` = qcCriteriaLevel, 
#                        `QC Description` = qcCriteria, 
#                        Value = qcValues)

qcCriteria <- c("Well Sequencing and Alignment", "Cell Hashing", "Cell Labeling", "Control Sample")
qcMessage <- c("Warning", "Pass", "Pass", "Pass")

final_qc <- data.table(`Category` = qcCriteria, 
                       Results = qcMessage,
                       Description = "                      ")

final_qc %>% 
  gt::gt() %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.3)
      ),
    locations = cells_body(
      columns = vars(Results),
      rows = grepl("Warning",Results))
  ) %>% 
  gt::tab_style(
    style = list(
      cell_fill(color = "red" , alpha = 0.5)
      ),
    locations = cells_body(
      columns = vars(Results),
      rows = grepl("Fail",Results))
  ) 

```  



### Session Information 
<a id="top_session_info"></a>  

Files Analyzed:  
```{r echo_files}
all_files_bn <- basename(all_files)
all_files_bn
```

Session Info:  
```{r Session Info}
sessionInfo()
```

Total time elapsed
```{r Show Time}
end_time <- Sys.time()
diff_time <- end_time - start_time
time_message <- paste0("Elapsed Time: ", 
                       round(diff_time, 3),
                       " ", units(diff_time))
print(time_message)
stm(time_message)
stm("H5 merge process complete.")
```  

[Return to Top](#top_session_info)

# {.tabset}
