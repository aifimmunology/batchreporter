#FILE_HANDLING.R

#' Load config file
#'
#' Loads a csv config file of analysis parameters
#'
#' Parameter file should have columns "parameter" containing parameter names,
#' "value" containing parameter values, and "type" containing variable classes.
#'
#' @param in_config Character value. Full file path to the config file.
#' @param vector_delim Character value. Delimiter to use to convert string to vector
#'
#' @return A list of parameters. Names from "parameter" and values from "value"
#' with classes defined per "type"
#' @export
#' @examples
#' my_config <- system.file("extdata/default_rna_config_v1.csv", package = "batchreporter")
#' cnfg <- load_config(my_config)
load_config <- function(in_config, vector_delim = ";"){
  # Read file in
  df <- read.csv(in_config, stringsAsFactors = FALSE)

  # check file expectations
  assertthat::assert_that(all(c("parameter", "value", "type") %in% names(df)))

  # Create variables for each "parameter" with value "value"
  lconfig <- as.list(df$value)
  names(lconfig) <- df$parameter

  # Convert delimited strings to vectors
  lconfig <- sapply(lconfig, strsplit, split = vector_delim)

  # Assign classes based on "type" column
  lconfig <- mapply(function(x,y){
    if(y == "factor") factor(x, levels = unique(x))
    else class(x) <- y; x
  },lconfig, df$type)

  return(lconfig)
}

#' Validate configuration
#'
#' Validate that configuration contains expected parameters and those parameters
#' are non-missing
#'
#' @param cnfg Configuration paramter list generated by \code{batchreporter::load_config()}
#' @param expected_parameters Character object. Vector of expected parameter names
#' in the cnfg list
#'
#' @return NULL. If missing parameters, error is thrown with descriptive message
#' @export
validate_config <- function(cnfg, expected_parameters){
  if(!all(expected_parameters %in% names(cnfg))){
    p_missing <- setdiff(expected_parameters, names(cnfg))
    stop(sprintf("Missing parameters in configuration file: %s",
                 paste(p_missing, collapse = ", ")))
  }

  cnfg_no_NA <- cnfg[!is.na(cnfg)]
  if(!all(expected_parameters %in% names(cnfg_no_NA))){
    p_NA <- setdiff(expected_parameters, names(cnfg_no_NA))
    stop(sprintf("Missing values for expected parameters in configuration file: %s",
                 paste(p_NA, collapse = ", ")))
  }
}

#' Read H5 Well Metadata
#'
#' Read in 10x well metadata from an H5 file. Metadata is injected to the
#' 10x Genomics cellranger h5 output by AIFI pipeline code.
#'
#' @param h5_file the path to an .h5 file with metadata injection by AIFI pipeline.
#' @param target A specific matrix object in the .h5 file. Default is "well". Can also work with any matrix-like object
#' nested further if target is equal to the full path (ie matrix/features)--matrix will be read in as-is.
#' For reading cell level metadata use \code{H5weaver::read_h5_cell_metadata()} and for reading
#' sparse matrixes use \code{H5weaver::read_h5_dgCMatrix()}
#' @return A data.frame containing all feature metadata found in /well
#' @export
read_h5_well_meta <- function (h5_file, target = "well") {
  assertthat::assert_that(is.character(h5_file))
  assertthat::assert_that(length(h5_file) == 1)
  target <- ifelse(grepl("^/", target), target, paste0("/",
                                                       target))
  h5_contents <- H5weaver::h5ls(h5_file)
  target_contents <- h5_contents[grepl(paste0("^", target,"$"),
                                       h5_contents$group), ]
  h5_meta_targets <- target_contents$full_name

  if (length(h5_meta_targets) > 0) {
    meta_list <- lapply(h5_meta_targets, function(h5_meta_target) {
      rhdf5::h5read(h5_file, h5_meta_target)
    })
    rhdf5::h5closeAll()
    names(meta_list) <- sub(".+/", "", h5_meta_targets)
    meta_list <- H5weaver::strip_1d_array_recursive(meta_list)
    meta_list <- H5weaver::convert_char_na_recursive(meta_list)
    df <- as.data.frame(meta_list, stringsAsFactors = FALSE)
    if("well_id" %in% names(df)){
      df <- df[, c("well_id", setdiff(names(df),"well_id"))]
    }
    df
  }
  else {
    stop("No well metadata found in h5_file.")
  }
}

#' Read in HTO Processing Metrics JSON Files
#'
#' @param fp Full file path to a single json file to be read. JSON files are generated
#' by the AIFI pipeline
#' @param sample_column_name Name to use for the sample id's. Ie for pbmc runs use
#' "pbmc_sample_id" (default) since the pipeline uses this column name in the metadata. Column
#' name may be different in future for other sample types.
#' @return A data frame of select hashing information for each well and HTO
#' @export
#' @examples
#' raw_json <- system.file("extdata/X002/hash/X002-P1C1W4_hto_processing_metrics.json",
#'                        package = "batchreporter")
#' df_json <- read_hto_well_json(raw_json)
#' head(df_json)
read_hto_well_json <- function(fp, sample_column_name = "pbmc_sample_id"){
  assertthat::assert_that(length(fp) == 1, msg = "Input fp is not length 1")

  json_list <- jsonlite::read_json(fp)

  well_id <- json_list$well_id
  sample_stats_list <- json_list$pbmc_sample_hto_stats
  sample_stats_df_list <- lapply(seq_along(sample_stats_list), function(i){
    df <- data.frame(names(sample_stats_list)[i])
    names(df)[1] <- sample_column_name
    stats_list <- lapply(sample_stats_list[[i]], function(x){
      ifelse(is.null(x),NA, x)
    })
    df <- cbind(df, as.data.frame(stats_list))
    df
  })

  sample_stats_df <- do.call(rbind, sample_stats_df_list)
  results <- data.frame(well_id = rep(well_id, nrow (sample_stats_df)),sample_stats_df)
}


#PLOT_FUNCTIONS.R

#' QC Stacked Barplot with Faceting
#'
#' The metric used for category_x will generate bars as columns on the x-axis. The bar will be split vertically based on category_y.
#' Facet wrapping will be performed on supplied variables based on the facet_formula.
#'
#' @param meta A data.frame containing metadata
#' @param category_x A character object specifying the metadata to use for splitting in the x-direction
#' @param name_x A character object specifying a name to display on the x-axis
#' @param category_y  A character object specifying the metadata to use for color groups
#' @param category_name A character object specifying a name to display for the colors
#' @param colorset_y A colorset to use as fills for category_y. Currently supported: "rainbow" or "varibow". Default is "varibow"
#' @param name_y 	A character object specifying a name for the y-axis.
#' @param as_fraction A logical object specifying whether or not to display the stacked bars as fractions of the total count for each category_x. Default is FALSE.
#' @param facet_formula A formula object for faceting based on variables in the meta data frame. For example, \code{formula("~pool_id")} will facet wrap by a variable called pool_id in meta.
#' @param ... Additional arguments passed to \code{ggplot2::facet_wrap()}
#' @return A ggplot2 plot object
#' @import data.table
#' @import ggplot2
#' @export
qc_stacked_barplot_facet <- function (meta,
                                      category_x = "batch_id",
                                      name_x = "Batch ID",
                                      category_y = "well_id",
                                      category_name = "Well ID",
                                      colorset_y = "varibow",
                                      name_y = "N Cells",
                                      as_fraction = FALSE,
                                      facet_formula = NULL, ...) {
  assertthat::assert_that(sum(class(meta) %in% c("data.frame",
                                                 "data.table")) > 0)
  assertthat::assert_that(class(category_x) == "character")
  assertthat::assert_that(length(category_x) == 1)
  assertthat::assert_that(category_x %in% names(meta))
  assertthat::assert_that(class(name_x) == "character")
  assertthat::assert_that(length(name_x) == 1)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(class(name_y) == "character")
  assertthat::assert_that(length(name_y) == 1)
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow", "varibow"))
  assertthat::assert_that(class(as_fraction) == "logical")
  assertthat::assert_that(is.null(facet_formula) || rlang::is_formula(facet_formula))
  meta <- data.table::as.data.table(meta)

  if(!is.null(facet_formula)){
    formula_cols <- as.character(as.list(facet_formula))
    f_cols <- setdiff(formula_cols, "`~`")
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x,
                                                              category_y, f_cols))]
  } else {
    count_table <- meta[, .(n_cells = nrow(.SD)), by = mget(c(category_x,
                                                              category_y))]
  }
  plot_xpos <- data.frame(unique(count_table[[category_x]]))
  names(plot_xpos) <- category_x
  plot_xpos <- plot_xpos[order(plot_xpos[[category_x]]), ,
                         drop = FALSE]
  plot_xpos$xpos <- 1:nrow(plot_xpos)
  count_table <- count_table[plot_xpos, on = category_x]
  plot_fills <- data.frame(unique(count_table[[category_y]]))
  names(plot_fills) <- category_y
  if (colorset_y == "rainbow") {
    set.seed(3030)
    plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)),
                              nrow(plot_fills))
  }
  else if (colorset_y == "varibow") {
    set.seed(3030)
    plot_fills$fill <- sample(H5weaver::varibow(nrow(plot_fills)),
                              nrow(plot_fills))
  }
  plot_fills <- plot_fills[order(plot_fills[[category_y]]),
  ]
  count_table <- count_table[plot_fills, on = category_y]
  count_table <- count_table[order(get(category_y), decreasing = TRUE)]
  if (as_fraction) {
    count_table <- count_table[, `:=`(ymax, cumsum(n_cells)/sum(n_cells)),
                               by = list(get(category_x))]
    count_table <- count_table[, `:=`(ymin, shift(ymax,
                                                  fill = 0, type = "lag")), by = list(get(category_x))]
  }
  p <- ggplot() + geom_rect(data = count_table,
                                              aes(xmin = xpos - 0.4, xmax = xpos + 0.4, ymin = ymin,
                                                           ymax = ymax, fill = fill)) + scale_fill_identity(category_name,
                                                                                                                     breaks = plot_fills$fill, labels = plot_fills[[category_y]],
                                                                                                                     guide = "legend") + scale_x_continuous(name_x,
                                                                                                                                                                     breaks = plot_xpos$xpos, labels = plot_xpos[[category_x]]) +
    scale_y_continuous(name_y) + theme_bw() +
    theme(axis.text.x = element_text(angle = 90,
                                                       hjust = 1, vjust = 0.3))
  if(!is.null(facet_formula)){
    p <- p +
      facet_wrap(facet_formula, ...)
  }
  p
}

#' Generate a baseline-aligned barplot for two categorical metrics with faceting
#'
#' The metric used for category_x will generate bars as columns on the x-axis.
#' The bar will be split vertically based on category_y. Each group in category_y
#' will be aligned to make them easier to compare. Facet wrapping will be
#' performed on supplied variables based on the facet_formula. By specifying "stat"
#' the function can accept either metadata that has been pre-aggregated or raw values
#' to be counted.
#'
#' @param meta A data.frame containing metadata
#' @param category_x A character object specifying the metadata to use for grouping on the x-axis
#' @param name_x A character object specifying a name to display on the x-axis
#' @param category_y A character object specifying the metadata to use for splitting in the y-direction
#' @param category_name A character object specifying a name to display for the colors
#' @param colorset_y A colorset to use as fills for category_y. Currently supported: "rainbow" or "varibow". Default is "varibow"
#' @param name_y A character object specifying a name for the y-axis.
#' @param padding A numeric object specifying the fraction of the total vertical space to use for separating category_y groups. Default is 0.2.
#' @param stat A character object specifying the stat method for the barplot. Default is "count", also supports "identity".
#' @param variable_y_identity A character object specifying a the values to plot on y axis when stat="identity"
#' @param facet_formula A formula object for faceting based on variables in the meta data frame. For example, \code{formula("~pool_id")} will facet wrap by a variable called pool_id in meta.
#' @param ... Additional arguments passed to \code{ggplot2::facet_wrap()}
#'
#' @return a ggplot2 plot object
#' @export
#' @examples
#' set.seed(3)
#' test_data_1 <- data.frame(batch_id=sample(c("B001","B002"),1000, replace = TRUE),
#'                         well_id = sample(c("W1","W2","W3"),1000, replace = TRUE),
#'                         sample_names= 1:1000)
#' qc_aligned_barplot_facet(test_data_1,
#'                          category_x = "batch_id",
#'                          name_x = "Batch ID",
#'                          category_y = "well_id",
#'                          category_name = "Well ID",
#'                          colorset_y = "varibow",
#'                          name_y = "N Cells",
#'                          padding = 0.2)
#'
#' test_data <- rbind(data.frame(row=1:1000,
#'                               pool_id="P1",
#'                               well_id = sample(c("W1","W2","W3"),1000, replace = TRUE),
#'                               sample_id= sample(1:3, 1000, replace = TRUE)),
#'                    data.frame(row=1001:2000,
#'                               pool_id="P2",
#'                               well_id = sample(c("W4","W5","W6"),1000, replace = TRUE),
#'                               sample_id= sample(4:6, 1000, replace = TRUE)))
#' qc_aligned_barplot_facet(test_data,
#'                          category_x = "well_id",
#'                          name_x = "Well ID",
#'                          category_y = "sample_id",
#'                          category_name = "Sample ID",
#'                          colorset_y = "varibow",
#'                          name_y = "N Cells",
#'                          padding = 0.2,
#'                          facet_formula = formula("~pool_id"),
#'                          scales = "free")
#'
#' \dontrun{  # uses tidyr
#' test_data_3 <- rbind(tidyr::expand_grid(pool_id = "P1",
#'                                sample_id = c("S1","S2","S3"),
#'                                well_id = c("W1","W2","W3")),
#'                    tidyr::expand_grid(pool_id = "P2",
#'                                sample_id = c("S4","S5","S6"),
#'                                well_id = c("W4","W5","W6"))
#'                  )
#' test_data_3$n_cells <- round(rnorm(nrow(test_data_2), 1000, 100))
#' qc_aligned_barplot_facet(test_data_3,
#'     category_x = "well_id",
#'     name_x = "Well ID",
#'     category_y = "sample_id",
#'     category_name = "Sample ID",
#'     colorset_y = "varibow",
#'     name_y = "N Cells",
#'     padding = 0.2,
#'     stat= "identity",
#'     variable_y_identity = "n_cells",
#'     facet_formula = formula("~pool_id"),
#'     scales = "free")
#' }
qc_aligned_barplot_facet <- function(meta,
                                     category_x = "batch_id",
                                     name_x = "Batch ID",
                                     category_y = "well_id",
                                     category_name = "Well ID",
                                     colorset_y = "varibow",
                                     name_y = "N Cells",
                                     padding = 0.2,
                                     stat = "count",
                                     variable_y_identity = NULL,
                                     facet_formula = NULL,
                                     ...) {

  assertthat::assert_that(sum(class(meta) %in% c("data.frame","data.table")) > 0)
  assertthat::assert_that(class(category_x) == "character")
  assertthat::assert_that(length(category_x) == 1)
  assertthat::assert_that(category_x %in% names(meta))
  assertthat::assert_that(class(name_x) == "character")
  assertthat::assert_that(length(name_x) == 1)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(class(name_y) == "character")
  assertthat::assert_that(length(name_y) == 1)
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow","varibow"))
  assertthat::assert_that(class(padding) == "numeric")
  assertthat::assert_that(length(padding) == 1)
  assertthat::assert_that(padding < 1)
  assertthat::assert_that(length(stat) == 1)
  assertthat::assert_that(class(stat) == "character")
  assertthat::assert_that(stat %in% c("count","identity"), msg = "parameter stat must be 'count' or 'identity'")
  assertthat::assert_that(ifelse(stat == "identity", length(variable_y_identity) == 1,TRUE),
                          msg = "If stat is 'identity', variable_y_idnetity must be supplied")
  assertthat::assert_that(ifelse(stat == "identity", class(variable_y_identity) == "character",TRUE))
  assertthat::assert_that(ifelse(stat == "identity", variable_y_identity %in% names(meta),TRUE))
  assertthat::assert_that(is.null(facet_formula) || class(facet_formula) == "formula")

  meta <- as.data.table(meta)
  if(!is.null(facet_formula)){
    f_list <- as.character(as.list(facet_formula))
    f_cols <- setdiff(f_list, c("`~`","[.]","+"))
    f_cols <- trimws(unlist(strsplit(f_cols, split = "\\+")))
    assertthat::assert_that(all(f_cols %in% names(meta)), msg = "Columns in facet formula must be present in input meta object")

    if(stat == "count"){
      count_table <- meta[, .(counts = nrow(.SD)), by = mget(c(category_x, category_y, f_cols))]
    } else if (stat == "identity"){
      count_table <- meta[, mget(c(category_x,category_y, f_cols, variable_y_identity))]
      count_table[, counts := get(variable_y_identity)]
    }
  } else {
    if(stat == "count"){
      count_table <- meta[, .(counts = nrow(.SD)), by = mget(c(category_x, category_y))]
    } else if (stat == "identity"){
      count_table <- meta[, mget(c(category_x, category_y, variable_y_identity))]
      count_table[, counts := get(variable_y_identity)]
    }
  }

  plot_xpos <- data.frame(unique(count_table[[category_x]]))
  names(plot_xpos) <- category_x
  plot_xpos <- plot_xpos[order(plot_xpos[[category_x]]),,drop = FALSE]
  plot_xpos$xpos <- 1:nrow(plot_xpos)

  count_table <- count_table[plot_xpos, on = category_x]

  plot_fills <- data.frame(unique(count_table[[category_y]]))
  names(plot_fills) <- category_y
  if(colorset_y == "rainbow") {
    set.seed(3030)
    plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)), nrow(plot_fills))
  } else if(colorset_y == "varibow") {
    set.seed(3030)
    plot_fills$fill <- sample(H5weaver::varibow(nrow(plot_fills)), nrow(plot_fills))
  }
  plot_fills <- plot_fills[order(plot_fills[[category_y]]),]
  count_table <- count_table[plot_fills, on = category_y]

  group_maxes <- count_table[, .(group_max = max(counts)), by = list(get(category_y))]
  names(group_maxes)[1] <- category_y
  group_maxes <- group_maxes[order(get(category_y), decreasing = TRUE)]
  group_maxes <- group_maxes[, cum_max := cumsum(group_max)]
  group_maxes <- group_maxes[, group_center := cum_max - group_max / 2]
  group_maxes <- group_maxes[, padded_center := group_center + (max(cum_max) * (padding/nrow(group_maxes))) * (1:nrow(group_maxes) - 1)]
  group_maxes <- group_maxes[, padded_base := padded_center - group_max/2]
  group_maxes <- group_maxes[, padded_top := padded_center + group_max/2]

  count_table <- count_table[group_maxes, on = category_y]

  count_table <- count_table[order(get(category_y), decreasing = TRUE)]
  count_table <- count_table[, ymax := cumsum(counts), by = list(get(category_x))]
  count_table <- count_table[, ymin := shift(ymax, fill = 0, type = "lag"), by = list(get(category_x))]

  p <- ggplot2::ggplot() +
    ggplot2::geom_rect(data = count_table,
                       ggplot2::aes(xmin = xpos - 0.4,
                                    xmax = xpos + 0.4,
                                    ymin = padded_base,
                                    ymax = padded_base + counts,
                                    fill = fill)) +
    ggplot2::geom_hline(data = count_table,
                        ggplot2::aes(yintercept = padded_base)) +
    ggplot2::geom_hline(data = count_table,
                        ggplot2::aes(yintercept = padded_top),
                        linetype = "dashed") +
    ggplot2::scale_fill_identity(category_name,
                                 breaks = plot_fills$fill,
                                 labels = plot_fills[[category_y]],
                                 guide = "legend") +
    ggplot2::scale_x_continuous(name_x,
                                breaks = plot_xpos$xpos,
                                labels = plot_xpos[[category_x]]) +
    ggplot2::scale_y_continuous(name_y,
                                breaks = c(group_maxes$padded_base,
                                           group_maxes$padded_top),
                                labels = c(rep("", nrow(group_maxes)),
                                           group_maxes$group_max),
                                expand = ggplot2::expand_scale(c(0, 0.02))) +
    ggplot2::theme_bw() +
    ggplot2::theme(panel.grid.minor.y = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_text(angle = 90,
                                                       hjust = 1,
                                                       vjust = 0.3))

  if(!is.null(facet_formula)){
    p <- p +
      facet_wrap(facet_formula, ...)
  }

  p
}


#' Add Axis Spacing for Faceted Plotly
#'
#' Note: This does not work as expected in Rmarkdown
#' Add lines of whitespace to x-axis or y-axis title to shift title down or left.
#'
#'
#' @param plotly_obj An object generated by ggplotly
#' @param axis String value of "x" or "y". Which axis title to add spacing to.
#' If need to add spacing to both, make separate calls to `add_axis_title_spacing_plotly()`
#' @param n_lines Numeric value. Number of lines worth of spacing to add.
#' @return A the original plotly object with updated axis name
#' @examples
#' \dontrun{  # THIS FUNCTION NOT CURRENTLY EXPORTED
#' library(ggplot2)
#' library(plotly)
#' library(dplyr)
#' set.seed(1)
#' x <- sapply(1:10,function(x){paste(LETTERS[sample(1:26,10,replace = TRUE)],collapse="")})
#' y <- sapply(1:20,function(x){paste(LETTERS[sample(1:26,10,replace = TRUE)],collapse="")})
#' z <- rep(c("A","B"), times = 10)
#' df <- data.frame(x, y, z)
#' g <- ggplot(df, aes(x, y))+
#'   geom_point()+
#'   facet_wrap(~z, nrow =1) +
#'   xlab("X TITLE") +
#'   ylab("Y TITLE") +
#'   theme(axis.text.x = element_text(angle = 90))
#' g
#' gp <- ggplotly(g)
#' gp
#' gp %>%
#'   add_axis_title_spacing_plotly("x", 3) %>%
#'   add_axis_title_spacing_plotly("y", 3)
#' }
#'
add_axis_title_spacing_plotly <- function(plotly_obj, axis, n_lines){
  assertthat::assert_that(is.character(axis))
  axis <- tolower(axis)
  assertthat::assert_that(axis %in% c("x","y"))
  assertthat::assert_that(is.numeric(n_lines))

  axis_string <- paste0(axis,"axis")

  annotation_index <- (axis=="y") + 1
  orig_title <- plotly_obj$x$layout$annotations[[annotation_index]]$text
  if(is.null(orig_title)){
    stop(sprintf("No title detected in plotly object for axis %s", axis))
  }

  spacing_string <- paste("",rep("\n",n_lines), collapse = "")
  if(axis == "x"){
    newtitle <- paste0(spacing_string, orig_title)
  } else if (axis == "y"){
    newtitle <- paste0(orig_title, spacing_string)
  }

  plotly_obj$x$layout$annotations[[annotation_index]]$text <- newtitle

  return(plotly_obj)
}

#' Add Axis Spacing for Faceted Plotly
#'
#' Adjusts the axis titles in plotly objects by modifying the object itself,
#' since plotly's auto spacing does not do this appropriately for faceted plots
#'
#' @param plotly_obj An object generated by ggplotly
#' @param axis String value of "x" or "y". Which axis title to add spacing to.
#' If need to add spacing to both, make separate calls to `adjust_axis_title_spacing_plotly()`
#' @param adjustment Numeric value. Vertical (for x-axis) or horizontal (for y-axis) adjustment for axis title
#' @return A the original plotly object with updated axis name
#' @export
#' @examples
#' library(ggplot2)
#' library(plotly)
#' library(dplyr)
#' set.seed(1)
#' x <- sapply(1:10,function(x){paste(LETTERS[sample(1:26,10,replace = TRUE)],collapse="")})
#' y <- sapply(1:20,function(x){paste(LETTERS[sample(1:26,10,replace = TRUE)],collapse="")})
#' z <- rep(c("A","B"), times = 10)
#' df <- data.frame(x, y, z)
#' g <- ggplot(df, aes(x, y))+
#'   geom_point()+
#'   facet_wrap(~z, nrow =1) +
#'   xlab("X TITLE") +
#'   ylab("Y TITLE") +
#'   theme(axis.text.x = element_text(angle = 90))
#' g
#' gp <- plotly::ggplotly(g)
#' gp
#' gp %>%
#'   adjust_axis_title_spacing_plotly("x", 0.05) %>%
#'   adjust_axis_title_spacing_plotly("y", 0.05)
#'
adjust_axis_title_spacing_plotly <- function(plotly_obj, axis, adjustment){
  assertthat::assert_that(is.character(axis))
  axis <- tolower(axis)
  assertthat::assert_that(axis %in% c("x","y"))
  assertthat::assert_that(is.numeric(adjustment))

  annotation_index <- (axis=="y") + 1

  if(axis == "x"){
    plotly_obj$x$layout$annotations[[annotation_index]]$y <- adjustment
  } else if (axis == "y"){
    plotly_obj$x$layout$annotations[[annotation_index]]$x <- adjustment
  }

  return(plotly_obj)
}

#' Plot UMAP
#'
#' Standardized UMAP plotting with color customization for grouping variables
#'
#' @param df A data frame containing umap data and metadata for plotting
#' @param x_col Character value. Name of data column to plot on the x-axis
#' @param x_lab Character value. Name to display on the x-axis
#' @param y_col CHaracter value. Name of data column to plot on the y-axis
#' @param y_lab Character value. Name to display on the y-axis
#' @param title Character value. Title of plot.
#' @param point_size Numeric value. Point size to use for scatter plot
#' @param color_col Character value, Name of data column used to color point by groups or value
#' @param scale_color_fun A function that returns color scaling for ggplot2
#' @param ... Additional arguments passed to \code{scale_color_fun}
#' @return A ggplot2 plot object
#' @import ggplot2
#' @export
plot_umap_report <- function(df, x_col, x_lab, y_col, y_lab, title, point_size, color_col, scale_color_fun,...){
  g <- ggplot(df, aes_string(x_col, y_col)) +
    geom_point(alpha = 1, size = point_size, aes_string(color = color_col)) +
    ggtitle(title)+
    xlab(x_lab) +
    ylab(y_lab) +
    scale_color_fun(...) +
    theme_bw() +
    theme(aspect.ratio = 1/1,
          text = element_text(size = 20))
  return(g)

}

#' Pretty Color-Gradient-N Scaling across Data
#'
#' Creates a standard rainbow color scaling for set of values. Ensures default range
#' of interest will be colored consistently, with any observed values higher than
#' the default range colored a separate color. By default, expected range is blue to
#' red with high values as dark red. Default ranges were roughly based on genes per cell
#'
#' @param max_value Character value. Highest data value to extend color scale to.
#' @param colors Colors to use in  \code{scale_color_gradientn()}
#' @param value_breaks Values associated with each color, in order
#' @param highest_col Color to scale out to for observed values higher than
#' largest \code{value_breaks} value
#' @return A custom function of \code{scale_color_gradientn()} with colors, values, and breaks defined.
#' The function will accept additional arguments to \code{scale_color_gradientn()}
#' @import ggplot2
#' @export
#' @examples
#' library(ggplot2)
#' set.seed(3)
#' high_genes <- data.frame(x = runif(100, 0, 10), y = 1:100, n_genes = rnorm(100, 3500, 1000))
#' my_color_fun_high <- scale_color_manual_rainbow(max(high_genes$n_genes))
#' ggplot(high_genes, aes(x, y, color = n_genes))+ geom_point() + my_color_fun_high()
#'
#' super_high_genes <- data.frame(x = runif(100, 0, 10), y = 1:100, n_genes = runif(100, 3000, 9000))
#' my_color_fun_super_high <- scale_color_genes(max(super_high_genes$n_genes))
#' ggplot(super_high_genes, aes(x, y, color = n_genes))+ geom_point() + my_color_fun_super_high()
#'
#' low_genes <- data.frame(x = runif(100, 0, 10), y = 1:100, n_genes = runif(100, 0, 2900))
#' my_color_fun_low <- scale_color_genes(max(low_genes$n_genes))
#' ggplot(low_genes, aes(x, y, color = n_genes))+ geom_point() + my_color_fun_low()
scale_color_manual_rainbow <- function(max_value,
                                       colors = c("blue","deepskyblue","green3", "yellow","orange","red"),
                                       value_breaks = c(0,500, 1000, 2000, 3000, 4000),
                                       highest_col = "darkred"){
  function(...){
    if(max_value > max(value_breaks)){
      scale_color_gradientn(limits = c(0, max_value),
                            colours = c(colors, highest_col),
                            values = scales::rescale(c(value_breaks, max_value),
                                                     from = c(0, max_value)),
                            breaks = pretty(c(0, max_value), n = 4, min.n = 3), ...)
    } else {
      i_max_break <- which(value_breaks > max_value)[1] # smallest break greater than data
      scale_color_gradientn(limits = c(0, value_breaks[i_max_break]),
                            colours = colors[1:i_max_break],
                            values = scales::rescale(value_breaks[1:i_max_break],
                                                     from = c(0, value_breaks[i_max_break])),
                            breaks = pretty(c(0, value_breaks[i_max_break]), n = 4, min.n = 3), ...)
    }
  }
}

#' Default Color Gradient for Genes per Cell
#'
#' Uses \code{} with default values to create a gradient for genes per cell, with
#' scale adjusting to observed values
#'
#' @param max_value Character value. Highest genes per cell value in the dataset
#' @return A custom function of \code{scale_color_gradientn()} with colors, values,
#' and breaks defined. The function will accept additional arguments to \code{scale_color_gradientn()}
#' @export
scale_color_genes <- function(max_value){
  scale_color_manual_rainbow(max_value,
                             colors = c("blue","deepskyblue","green3", "yellow","orange","red"),
                             value_breaks = c(0, 500, 1000, 2000, 3000, 4000),
                             highest_col = "darkred")
}

#' Default Color Gradient for UMI per Cell
#'
#' Uses \code{} with default values to create a gradient for UMI per cell, with
#' scale adjusting to observed values
#'
#' @param max_value Character value. Highest UMI per cell value in the dataset
#' @return A custom function of \code{scale_color_gradientn()} with colors, values,
#' and breaks defined. The function will accept additional arguments to \code{scale_color_gradientn()}
#' @export
scale_color_umis <- function(max_value){
  scale_color_manual_rainbow(max_value,
                             colors = c("blue","deepskyblue","green3", "yellow","orange","red"),
                             value_breaks = c(0,1000, 3000, 5000, 7500, 10000),
                             highest_col = "darkred")
}


#' Default Color Gradient for Fraction Values
#'
#' Creates a default color gradient for fractional values using \code{scale_color_gradientn()}
#'
#' @param colors Colors for \code{scale_color_gradientn()}.
#' @param breaks Breaks for \code{scale_color_gradientn()}.
#' @param ... Additional arguments passed to \code{scale_color_gradientn()}
#' @return A custom function of \code{scale_color_gradientn()} for fractional values with colors, values,
#' and breaks defined. The function will accept additional arguments to \code{scale_color_gradientn()}
#' @export
scale_color_fct_mito <- function(colors = c("blue", "green3","yellow","red"),
                                 breaks = c(0,0.25,0.5,0.75,1), ...){
  ggplot2::scale_color_gradientn(limits = c(0, 1),
                       colors = colors,
                       breaks = breaks,...)
}

#' Seurat 3 Cell Palette
#'
#' Color palette with color assigned to each cell type in Seurat v3 labeling
#' reference (variable_pbmc_10k_v3)
#'
#' @return A data frame with columns "seurat3_pbmc_type" and "cell_color"
#' @export
seurat_3_cell_palette <- function(){
  data.frame(cell_labels = c("B cell progenitor", "CD14+ Monocytes", "CD16+ Monocytes",
                                   "CD4 Memory", "CD4 Naive","CD8 effector", "CD8 Naive",
                                   "Dendritic cell", "Double negative T cell", "NK cell",
                                   "pDC", "Platelets", "pre-B cell"),
             cell_color = c("#FF0000","#FF8C00","#FFEE00","#44FF00", "#00E1FF","#0000FF",
                            "#E546FA","#F598E5","#008A12", "#803CCF", "#967729", "#B1C4F0",
                            "#DCF0B1"),
             stringsAsFactors = FALSE)
}

#' Load Cell Label Color Palette
#'
#' For recognized labeling methods loads a cell-type specific color palette,
#' otherwise genreates a varibow palette based on number of cell types in data
#' @param cell_label_method Character value. Cell labeling method. Currently only
#' defined method is Seurat3.
#' @param cell_labels Character vector. All cell type labels in the dataset.
#' @return Dataframe of cell types and corresponding colors.
#' @export
#' @examples
#' get_cell_label_palette(cell_label_method = "Seurat3")
#' \dontrun{get_cell_label_palette(cell_label_method = "SpecialLabelMethod") ## generates intentional error}
#' get_cell_label_palette(cell_label_method = "SpecialLabelMethod",
#'                        cell_labels = c("Label1","Label2","Label3"))
get_cell_label_palette <- function(cell_label_method = "Seurat3", cell_labels=NULL){
  if(cell_label_method == "Seurat3"){
    seurat_3_cell_palette()
  } else {
    assertthat::assert_that(!is.null(cell_labels),
                            msg = "Unrecognized cell label method. Must supply cell_labels to generate a custom palette")
    unique_labels = unique(sort(cell_labels,na.last = TRUE))
    n_labels <- length(unique_labels)
    pal_colors <- H5weaver::varibow(n_labels)
    df_pal <-   data.frame(cell_labels = unique_labels,
                           cell_color = pal_colors,
                           stringsAsFactors = FALSE)
    df_pal
  }
}

#' QC Pie Chart with Optional Faceting
#'
#' Create a pie chart with wedges specified by a grouping variable. Faceting may be performed
#' if facetting is provided. 
#'
#' The grouping variable used for category_y will generate the wedges of the bar plot. The supplied
#' dataframe can either be one observation per row or one row per category_y. If the former, "stat" should be 
#' "count", in which case counts of each category will be calculated. If the latter, "stat" should be
#' "identity", and a column containing the category counts should be supplied ("variable_y_identity"). 
#' Facet wrapping will be performed on supplied variables based on the facet_formula. 
#'
#' @param meta A data.frame containing metadata
#' @param category_y  A character value specifying the metadata column to use for color groups
#' @param category_name A character value specifying a name to display for the category colors
#' @param stat A character value, either "count" or "identity", depending on whether input data
#' has already been aggregated by the category_y grouping variable. Default is "count".
#' @param palette_df_group An optional data frame containing two columns defining the 
#' categorical data color palette. The first column contains label values for 
#' all levels of category_y and the second column contains the color for each 
#' label. If NULL (default) random colors will be generated via the colorset_y
#' parameter.
#' @param colorset_y A colorset to use as fills for category_y. Currently 
#' supported: "rainbow" or "varibow". Default is "varibow". Only used when
#' palette_df_group is NULL.
#' @param variable_y_identity Value to use as labels for the pie wedge. Currently supported
#' values are "p
#' @param plot_font_size Numeric value. General size of text on plot in font size. Default is 14.
#' @param label_size Size of text to label each pie wedge. Default is 3
#' @param text_repel_x Numeric value. X coordinate for plotting pie wedge labels 
#' using \code{ggrepel::geom_text_repel()}. Default is 1.5
#' @param nudge_x_label Numeric value. Distance to nudge label in X coordinate 
#' for plotting pie wedge labels using \code{ggrepel::geom_text_repel()}. Higher
#' values will increase line length. Default is 0.5.
#' @param facet_formula A formula object for faceting based on variables in the meta data frame. 
#' For example, \code{formula("~pool_id")} will facet wrap by a variable called pool_id in meta. 
#' Currently only actual column names (rather than variables) supported for this argument.
#' @param ... Additional arguments passed to \code{ggplot2::facet_wrap()}
#' @return A ggplot2 plot object
#' @import data.table
#' @import ggplot2
#' @importFrom ggrepel geom_text_repel
#' @export
#' @examples 
#' \dontrun{
#' set.seed(2021)
#' my_palette <- batchreporter::get_cell_label_palette()
#' cell_probs <- c(0.025, 0.20, 0.03, 0.192, 0.18, 0.14, 0.05,
#'                 0.005, 0.02, 0.1 ,0.001,0.008,0.049)
#' test_data_1 <- data.frame(cell_type = sample(my_palette[,1], 500, 
#'                                              prob = cell_probs, replace = TRUE),
#'                         group = sample(c("MT UMI>0.1", "MT UMI<0.1"), 500, 
#'                                        prob = c(0.1, 0.9), replace = TRUE),
#'                         sample_names= 1:500)
#' # Use a predefined palette
#' qc_piechart(test_data_1,
#'             category_y = "cell_type", 
#'             category_name = "Cell Type",
#'             stat = "count",
#'             palette_df_group = my_palette,
#'             plot_font_size = 14,
#'             label_size = 3,
#'             text_repel_x = 1.5, 
#'             nudge_x_label = 0.2,
#'             facet_formula = as.formula("~group"))
#' # Use default random palette
#' qc_piechart(test_data_1,
#'             category_y = "cell_type",
#'             stat = "count",
#'             label_size = 3,
#'             text_repel_x = 1.5, 
#'             nudge_x_label = 0.2,
#'             facet_formula = as.formula("~group"))
#' 
#' # No Facetting
#' qc_piechart(test_data_1,
#'             category_y = "cell_type",
#'             stat = "count",
#'             label_size = 3,
#'             text_repel_x = 1.5, 
#'             nudge_x_label = 0.2)
#'
#' # Stat = "identity" version, precalculated counts
#' test_data_2 <- data.frame(cell_type = rep(my_palette[,1], times = 2),
#'                          group = rep(c("MT UMI>0.1", "MT UMI<0.1"), each = nrow(my_palette)),
#'                          sample_names= 1:(2*nrow(my_palette)),
#'                          group_count = c(round(1000*cell_probs),round(4000*sample(cell_probs))))
#' test_data_2
#' qc_piechart(test_data_2,
#'             category_y = "cell_type",
#'             stat = "identity",
#'             variable_y_identity = "group_count",
#'             label_size = 3,
#'             text_repel_x = 1.5, 
#'             nudge_x_label = 0.2,
#'             facet_formula = as.formula("~group"))
#' } # end don't run


qc_piechart <- function(meta, 
                         category_y,
                         category_name = "Cell Type", 
                         stat = "count",
                         variable_y_identity = NULL,
                         palette_df_group = NULL, 
                         colorset_y = "varibow",
                         plot_font_size = 14, 
                         label_size = 3,
                         text_repel_x = 1.5,
                         nudge_x_label = 0.5,
                         facet_formula = NULL, ...) {
  
  assertthat::assert_that(sum(class(meta) %in% c("data.frame",
                                                 "data.table")) > 0)
  assertthat::assert_that(class(category_y) == "character")
  assertthat::assert_that(length(category_y) == 1)
  assertthat::assert_that(category_y %in% names(meta))
  assertthat::assert_that(class(category_name) == "character")
  assertthat::assert_that(length(category_name) == 1)
  assertthat::assert_that(ifelse(!is.null(palette_df_group),
                                 all(unlist(meta[,category_y]) %in% palette_df_group[,1]),
                                 TRUE), 
                          msg = "Supplied color palette must contain all levels of category variable.")
  assertthat::assert_that(class(colorset_y) == "character")
  assertthat::assert_that(length(colorset_y) == 1)
  assertthat::assert_that(colorset_y %in% c("rainbow", "varibow"))
  assertthat::assert_that(length(stat) == 1)
  assertthat::assert_that(class(stat) == "character")
  assertthat::assert_that(stat %in% c("count", "identity"), msg = "parameter stat must be 'count' or 'identity'")
  assertthat::assert_that(ifelse(stat == "identity", length(variable_y_identity) ==
                                   1, TRUE), msg = "If stat is 'identity', variable_y_identity must be supplied")
  assertthat::assert_that(ifelse(stat == "identity", class(variable_y_identity) ==
                                   "character", TRUE))
  assertthat::assert_that(ifelse(stat == "identity", variable_y_identity %in% names(meta), TRUE))
  assertthat::assert_that(is.null(facet_formula) || 
                            class(facet_formula) == "formula")
  meta <- as.data.table(meta)
  
  # Format and calculate count table using relevant grouping variables and values
  if (!is.null(facet_formula)) {
    f_list <- as.character(as.list(facet_formula))
    f_cols <- setdiff(f_list, c("`~`", "[.]", "+"))
    f_cols <- trimws(unlist(strsplit(f_cols, split = "\\+")))
    assertthat::assert_that(all(f_cols %in% names(meta)), 
                            msg = "Columns in facet formula must be present in input meta object")
    if (stat == "count") {
      count_table <- meta[, .(counts = nrow(.SD)), by = mget(c(category_y, f_cols))]
    }
    else if (stat == "identity") {
      count_table <- meta[, mget(c(category_y, f_cols, variable_y_identity))]
      count_table[, `:=`(counts, get(variable_y_identity))]
    }
    count_table[, `:=`(pct = counts/sum(counts)) , by = mget(c(f_cols))]
    count_table <- count_table[base::order(count_table[, ..category_y], decreasing = TRUE),]
    count_table[, `:=`(ypos =  cumsum(pct)- 0.5*pct) , by = mget(c(f_cols))]
  }
  else {
    if (stat == "count") {
      count_table <- meta[, .(counts = nrow(.SD)), by = mget(category_y)]
    }
    else if (stat == "identity") {
      count_table <- meta[, mget(c(category_y, variable_y_identity))]
      count_table[, `:=`(counts, get(variable_y_identity))]
    }
    count_table[, `:=`(pct = counts/sum(counts))]
    count_table <- count_table[base::order(count_table[, ..category_y], decreasing = TRUE),]
    count_table[, `:=`(ypos =  cumsum(pct)- 0.5*pct) ]
    
  }
  
  # Color palette
  if(!is.null(palette_df_group)){
    plot_fills <- palette_df_group
    names(plot_fills) <- c(category_y, "fill")
  } else {
    plot_fills <- data.frame(unique(count_table[[category_y]]))
    names(plot_fills) <- category_y
    if (colorset_y == "rainbow") {
      set.seed(3030)
      plot_fills$fill <- sample(grDevices::rainbow(nrow(plot_fills)), 
                                nrow(plot_fills))
    }
    else if (colorset_y == "varibow") {
      set.seed(3030)
      plot_fills$fill <- sample(H5weaver::varibow(nrow(plot_fills)), 
                                nrow(plot_fills))
    }
    plot_fills <- plot_fills[order(plot_fills[[category_y]]), ]
  }
  
  # Plot
  p <- ggplot(count_table, aes(x = 1, y=pct, fill=!!rlang::parse_expr(category_y))) +
    geom_bar(stat="identity", width = 1, color="white") +
    coord_polar("y", start = 0) +
    scale_fill_manual(name = category_name, values = plot_fills$fill, breaks = plot_fills[,category_y]) +
    ggrepel::geom_text_repel(aes(label = !!rlang::parse_expr(category_y), x=text_repel_x, y = ypos), 
                    color = "black", size = label_size, segment.size = 0.4, nudge_x = nudge_x_label,
                    show.legend = TRUE) +
    theme_void() + 
    theme(text = element_text(size = plot_font_size), 
          strip.text = element_text(face = "bold"))
  
  if (!is.null(facet_formula)) {
    p <- p + facet_wrap(facet_formula, ...)
  }
  
  return(p)
}

#RMARKDOWN_FORMATTING.R
# Rmarkdown formatting and QC utility functions

#' Knit a plot as a subchunk
#'
#' Knit a plot as a subchunk so its dimensions can be specified individually. Based
#' on code found here: http://michaeljw.com/blog/post/subchunkify/
#'
#' Allows individual plots within the same chunk to be knit as subchunks with
#' unique chunk options. Plots can be output in a loop with each plot using
#' different dimensions, ie dynamic dimensions based on number of x and/or y
#' category levels. Parent chunk should have chunk options 'results = "as-is"'
#' to ensure proper output. Note that this will create a "figures" directory in
#' the directory containing the Rmarkdown file containing the chunk plots. Ensure
#' that Rmarkdown  yaml has 'self_contained: true' in html document section (or equivalent)
#'
#' @param g The plot object
#' @param subchunk_name Character value. Unique name of Rmarkdown subchunk to be generated.
#' @param quiet_knit Logical value, default TRUE. Passed to \code{knitr::knit()}, should the subchunk
#' be knit "quietly" (no progress bar or messages)
#' @param chunk_opt_list Named list of chunk options for the subchunk. Can take any chunk
#' options available to a normal chunk.
#' @export
#' @examples
#' \dontrun{
#' # This will generate a file in 'figures' subdirectory of working directory
#' library(ggplot2)
#' g_example <- ggplot(data.frame(x=1:10, y = 1:10), aes(x, y)) + geom_point()
#' chunk_opt_l <- list(fig.height=10, fig.width=12, warning=TRUE)
#' make_subchunk(g_example, "test_chunk", chunk_opt_list = chunk_opt_l)
#' }
#'

make_subchunk <- function(g, subchunk_name, quiet_knit = TRUE, chunk_opt_list = list(fig.height=7, fig.width=5, warning = TRUE)) {
  if(is.null(subchunk_name)){
    subchunk_name <- paste0(as.numeric(Sys.time()), "_",)
  }

  g_deparsed <- paste0(deparse(
    function() {g}
  ), collapse = '')

  # construct chunk option string
  if(!is.null(chunk_opt_list)){
    option_names <- names(chunk_opt_list)
    option_string_list <- sapply(1:length(chunk_opt_list), function(i){
      val <- chunk_opt_list[[i]]
      val_type <- class(val)
      quote_string <- ifelse(val_type=="character","'","")
      val_fmt <- paste0(quote_string, val, quote_string)
      paste(names(chunk_opt_list)[i], val_fmt, sep = "=")
    })
    option_string <- paste(c(", ",option_string_list), collapse = ", ")
  } else {
    option_string <- ""
  }

  # construct full chunk
  sub_chunk <- paste0("\n```{r ", subchunk_name, option_string, "}",
                      "\n(", g_deparsed, ")()",
                      "\n```")

  # knit chunk
  cat(knitr::knit(text = knitr::knit_expand(text = sub_chunk), quiet = quiet_knit))
}

#' Create a simple HTML table of key and value pairs
#'
#' Create a simple table of paired values (ie name and value).
#'
#' @param labels Vector of labels
#' @param values Vector of values, same length as labels
#' @param col_widths_px Numeric vector of length 2. Widths in pixels of each column,
#' @param fontsize Numeric value. Default 2.
#' @export
#' @return HTML of formatted table.
#' @examples
#' lab1 <- c("Batch", "N Samples", "N Pools")
#' val1 <- c("B000", 16, 2)
#' h_tab <- simple_html_table(lab1, val1)
#' htmltools::html_print(h_tab)
simple_html_table <- function(labels, values, col_widths_px = c(300, 800), fontsize = 2){
  assertthat::assert_that(length(col_widths_px) %in% c(1,2))
  assertthat::assert_that(length(labels) == length(values))
  assertthat::assert_that(all(col_widths_px > 100) & all(col_widths_px < 1024))
  # assertthat::assert_that(ifelse(is.null(col.names),TRUE, length(col.names) == 2))
  # assertthat::assert_that(is.null(col.names) | class(col.names) == "character")

  if(length(col_widths_px) == 1){
    col_widths_px <- c(col_widths_px, col_widths_px)
  }

  create_row <- function(value1, value2 , col_widths_px = c(50, 50)){
    sprintf('<tr>
                <td style="width:%spx">
                  %s
                </td>
                <td style="width:%spx">
                  %s
                </td>
            </tr>',
            col_widths_px[1], value1, col_widths_px[2], value2)
  }

  add_table_wrap <- function(all_row_string, fontsize = 2, col_widths_px= c(50,50)){
    sprintf('<font size="%s">
            <style>
              table {
                border: 1px solid black;
                border-collapse: collapse;
              }
              td {
                padding: 5px;
                border: 1px solid black;
                border-collapse: collapse;
              }
            </style>
            <table>
              <colgroup>
                <col span="1" style="width: %spx;">
                <col span="1" style="width: %spx;">
              </colgroup>
              <tbody>
                %s
              </tbody>
            </table>
            </font>', fontsize, col_widths_px[1], col_widths_px[2], all_row_string)
  }

  row_strings <- character()
  for (i in seq_along(labels)){
    row_strings[i] <- create_row(labels[i], values[i], col_widths_px = col_widths_px)
  }
  row_string_all <- paste(row_strings, collapse = "")

  out_table <- add_table_wrap(row_string_all,fontsize = fontsize, col_widths_px = col_widths_px )

  htmltools::HTML(out_table)
}


#' Format Flags in GT Table
#'
#' CURRENTLY NOT USED. Apply standard formatting to "Comments" column of a gt table
#'
#' For "Comments" column, will fill cells containing pattern "Warning" in light red
#' and will fill cells containing pattern "Fail" in dark red.
#'
#' @param x A gt table object. Must contain a column named "Comments" with flags "Warning" or "Fail".
#' @return A gt table object with formatted Comments cells.
#' @importFrom magrittr %>%
#' @importFrom rlang .data
#' @export
#' @examples
#' set.seed(1)
#' vComments <- sample(c("Pass","Warning","Fail",NA), 10, replace = TRUE)
#' my_gt <- gt::gt(data.frame(X = 1:10, Comments = vComments))
#' my_gt
#' gt_fmt_comments(my_gt)
#' my_gt_nocommments <- gt::gt(data.frame(X = 1:10, CommentsX = vComments))
#' my_gt_nocommments
#' \dontrun{gt_fmt_comments(my_gt_nocommments)  # This intentionally generates an error}
gt_fmt_comments <- function(x) {
  assertthat::assert_that("Comments" %in% names(x[["_data"]]), msg = "Expect that gt contains flagging column named 'Comments'")

  x %>%
    gt::tab_style(
      style = list(
        gt::cell_fill(color = "red" , alpha = 0.3)
      ),
      locations = gt::cells_body(
        columns = gt::vars(Comments),
        rows = grepl("Warning", .data$Comments))
    ) %>%
    gt::tab_style(
      style = list(
        gt::cell_fill(color = "red" , alpha = 0.5)
      ),
      locations = gt::cells_body(
        columns = gt::vars(Comments),
        rows = grepl("Fail", .data$Comments))
    )
}


# Data summary functions

#' Get median and range
#'
#' Gets median and range of numeric vector, rounding to specified digits with option
#' to show the number of missing values. Median will always be calculated using
#' non-missing values.
#'
#' @param values Numeric vector
#' @param digits_round Number of digits to round to. Default 1.
#' @param comma_separate Logical, default TRUE. Should large values be displayed with comma separators
#' @param add_missing Logical, default TRUE. Should the number of missing values be displayed in brackets
#' @param verbose Logical, default TRUE. Should a message be printed upon successful calculation, including the number of missing values.
#' @return String value of formatted median and range. 'median (min-max) [missing]'
#' @import stats
#' @export
#' @examples
#' my_values <- c(1000:1010,NA)
#' get_median_range(my_values,
#'                  digits_round = 1,
#'                  comma_separate = TRUE,
#'                  add_missing = TRUE,
#'                  verbose = TRUE)
get_median_range <- function(values, digits_round = 1, comma_separate = TRUE, add_missing = TRUE, verbose = TRUE){
  assertthat::assert_that(mode(values) == "numeric" | all(is.na(values))) # can be any type of numeric, allow calculation if all missing
  assertthat::assert_that(length(values) > 0)

  fmt_num <- function(num){
    formatC(num, digits = digits_round, big.mark = ifelse(comma_separate,",",""), format = "f")
  }

  i_missing <- which(is.na(values))
  n_missing <- length(i_missing)
  has_missing <- n_missing > 0

  if(has_missing){
    values <- values[-i_missing]
  }

  med_string <- fmt_num(median(values))

  if(length(values) > 0){
    range_val <- fmt_num(range(values))
  } else {
    range_val <- c(NA,NA)
  }
  range_string <- paste(range_val, collapse = "-")
  med_range_string <- sprintf("%s (%s)", med_string, range_string)

  if(add_missing & has_missing){
    med_range_string <- sprintf("%s [%s]", med_range_string, n_missing)
  }

  if(verbose){
    cat(sprintf("Median and range calculated. Removed %s missing values", n_missing), sep = "\n")
  }

  return(med_range_string)
}


#' Get formatted range
#'
#' Gets range of numeric vector, rounding to specified digits with option
#' to show the number of missing values.
#'
#' @param values Numeric vector
#' @param digits_round Number of digits to round to. Default 1.
#' @param comma_separate Logical, default TRUE. Should large values be displayed with comma separators
#' @param add_missing Logical, default TRUE. Should the number of missing values be displayed in brackets
#' @param verbose Logical, default TRUE. Should a message be printed upon successful calculation, including the number of missing values.
#' @return String value of formatted median and range. 'median (min-max) [missing]'
#' @export
#' @examples
#' my_values <- c(1000:1010,NA)
#' get_range(my_values, digits_round = 1, comma_separate = TRUE, add_missing = TRUE, verbose = TRUE)
get_range <- function(values, digits_round = 1, comma_separate = TRUE, add_missing = TRUE, verbose = TRUE){
  assertthat::assert_that(mode(values) == "numeric" | all(is.na(values))) # can be any type of numeric, allow calculation if all missing
  assertthat::assert_that(length(values) > 0)

  fmt_num <- function(num){
    formatC(num, digits = digits_round, big.mark = ifelse(comma_separate,",",""), format = "f")
  }

  i_missing <- which(is.na(values))
  n_missing <- length(i_missing)
  has_missing <- n_missing > 0

  if(has_missing){
    values <- values[-i_missing]
  }

  if(length(values) > 0){
    range_val <- fmt_num(range(values))
  } else {
    range_val <- c(NA,NA)
  }
  range_string <- paste(range_val, collapse = "-")

  if(add_missing & has_missing){
    range_string <- sprintf("%s [%s]", range_string, n_missing)
  }

  if(verbose){
    cat(sprintf("Range calculated. Removed %s missing values", n_missing), sep = "\n")
  }

  return(range_string)
}

#' Determine passing specification
#'
#' This function is currently unused. Confirm functionality and modify if needed before use.
#' Flags numeric values above and/or below supplied upper and lower thresholds.
#'
#' @param values Numeric vector of values to evaluate for spec
#' @param lower_threshold Numeric value that represents the lower limit of acceptable values
#' @param upper_threshold Numeric value that represents the upper limit of acceptable values
#' @param digits_round The number of digits that values are to be rounded to before evaluation
#' @param pass_at_threshold Logical value. Whether or not values equal to threshold should pass, defaults to TRUE.
#' @param flag_values Vector of length 2 where the first value is the value to be returned for passing/non-flagged values
#' and the second value is the value to be returned for non-passing/flagged values.
#' @return Vector of length equal to input values. Output types defined by flag_values parameter
#' @export
#' @examples
#' myvalues <- 1:20
#' flags <- determine_passing_spec(myvalues,
#' lower_threshold = 5,
#' upper_threshold = 18,
#' pass_at_threshold = TRUE)
#' flags
#' flags2 <- determine_passing_spec(myvalues,
#' lower_threshold = 5,
#' upper_threshold = 18,
#' pass_at_threshold = FALSE)
#' flags2
determine_passing_spec <- function(values, lower_threshold = NULL, upper_threshold = NULL, digits_round = NULL, pass_at_threshold = TRUE, flag_values = c(FALSE,TRUE)){
  assertthat::assert_that(mode(values) == "numeric")
  assertthat::assert_that(length(values) >= 1)

  if (is.null(digits_round)){
    values_round <- values
  } else {
    values_round <- round(values, digits_round)
  }

  qc_flags <- rep(flag_values[1],length(values))

  # Flag values < or <= threshold
  if (!is.null(lower_threshold)){
    if (pass_at_threshold){
      i_low <- which(values_round < lower_threshold)
    } else {
      i_low <- which(values_round <= lower_threshold )
    }

    if (length(i_low) > 0){
      qc_flags[i_low] <- flag_values[2]
    }
  }

  # Flag values > or >= threshold
  if (!is.null(upper_threshold)){
    if (pass_at_threshold){
      i_high <- which(values_round > upper_threshold)
    } else {
      i_high <- which(values_round >= upper_threshold )
    }

    if (length(i_high) > 0){
      qc_flags[i_high] <- TRUE
    }
  }

  return(qc_flags)

}

markdown_colorize_html <- function(x, color) {
    sprintf("<span style='color: %s;'>%s</span>", color, x)
}

#SCRNA_ANALAYSIS.R

#' Sample cells
#'
#' Samples cells on labels, retaining an equal number of each label type.
#'
#' @param cl Named character vector. Values are cell labels and names are cell barcodes.
#' @param sample.size Integer value. Number of cells of each cell type to sample
#' @param seed Integer value. Seed passed to \code{set.seed()} for reproducible sampling.
#' @return Named character vector. Values are the cell barcodes selected and names are the labels
#' @export
sample_cells <- function(cl,
                         sample.size,
                         seed = 3030) {
  cl.cells <- split(names(cl), cl)
  sampled.cells <- sapply(names(cl.cells), function(x) {
    cells <- cl.cells[[x]]
    if (sample.size >= length(cells)) {
      return(cells)
    }
    to.sample <- pmin(sample.size, length(cells))

    set.seed(seed)
    sample(cells, to.sample)
  }, simplify = FALSE)
  sampled.cells <- unlist(sampled.cells)
  return(sampled.cells)
}
